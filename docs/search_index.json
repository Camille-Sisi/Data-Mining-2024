[["index.html", "DATA MINING Master Meci - Parcours PISE et CCESE - Option Data", " DATA MINING Master Meci - Parcours PISE et CCESE - Option Data Camille Signoretto, Maîtresse de conférences en économie, Université Paris Cité Février-juin 2024 "],["00-Presentation.html", "Présentation À propos de ce document Prérequis Remerciements Licence", " Présentation À propos de ce document Ce document est la version 2024 du cours de Data Mining dispensé aux étudiants de deuxième année de l’option Data du master MECI parcours PISE et CCESE. Ce cours est partagé avec Claude Grasland, dont vous trouverez la partie à l’adresse suivante : https://claudegrasland.github.io/datamining2024/. Ce document est régulièrement corrigé et mis à jour. La version de référence est disponible en ligne à l’adresse suivante : https://github.com/Camille-Sisi/Data-Mining-2024. Pour toute suggestion ou correction, n’hésitez pas à me contacter par mail. Prérequis Le seul prérequis pour suivre ce document est d’avoir installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux. Pour installer R, il suffit de se rendre sur une des pages suivantes1 : Installer R sous Windows Installer R sous Mac Pour installer RStudio, rendez-vous sur la page suivante et téléchargez la version adaptée à votre système : https://www.rstudio.com/products/rstudio/download/#download Remerciements Ce document a bénéficié des suggestions des étudiants qui en ont été les cobayes les premières années. Ce document est généré par l’extension bookdown de Yihui Xie et se base sur le template proposé par Julien Barnier pour introduire des exercices interactifs dans son cours de tidyverse. Licence Ce document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International. Sous Linux, utilisez votre gestionnaire de packages habituel.↩︎ "],["01-Base-de-donnees.html", "Section 1 Récupération de la base de données 1.1 Les données du Recensement de la Population (RP) 1.2 Quelles informations intéressantes dans cette base ?", " Section 1 Récupération de la base de données On va travailler cette année sur les données du Recensement de la Population (RP). C’est une base de données riche en informations, qui s’appuie sur les enquêtes annuelles du recensement et est produite par l’Insee. Les fichiers mis à disposition sur leur site sont au nombre de 9 : ils rassemblent des informations différentes, sur des espaces géographiques différents (canton ou ville, région), et à des niveaux d’analyse différents (individus, ménages/logements). Les derniers fichiers disponibles portent sur l’année 2020 mais nous allons travailer sur l’année 2019 qui rassemble les enquêtes annuelles du recensement (EAR) des années 2017 à 2021. Avant de rentrer plus dans les détails, on va charger les librairies principales que l’on va utiliser lors de cette séance (si elles ne sont pas installées sur votre RStudio, il faut le faire avant en utilisant la commande install.packages(\"nom.du.package\"), on pourra en appeler d’autres dans les deux sections suivantes. # Chargement des librairies library(tidyverse) library(data.table) library(gt) 1.1 Les données du Recensement de la Population (RP) On va travailler plus précisément à partir du fichier “Individus localisés au canton-ou-ville” qui décrit les caractéristiques des individus et celles des ménages qui les occupent. Les données sont localisées au niveau de la commune et de l’IRIS. On ne va pas s’intéresser à l’ensemble de la France, pour des questions d’intérêt et d’analyse, ainsi que des questions pratiques (ces fichiers étant lourds). On va donc télécharger uniquement ce fichier pour la zone A, c’est-à-dire l’Île-de-France. Le mieux est de télécharger le fichier puis le dézipper directement dans R comme ci-dessous en copiant le lien URL sur le site de l’Insee ; et on le stock dans le dossier “data” de notre projet R. Sinon, il reste possible de le télécharger via internet et de l’enregistrer dans un de vos dossiers bien spécifiés pour le “dézipper” ensuite. download.file(url=&quot;https://www.insee.fr/fr/statistiques/fichier/6544333/RP2019_INDCVIZA_csv.zip&quot;, destfile = &quot;data/RP2019_INDCVIZA_csv.zip&quot;) # Le fichier a donc été téléchargé dans le dossier intitulé &quot;data&quot; du projet R, on va # maintenant le dézipper et enregistrer les fichiers extraits dans le même dossier. unzip(&quot;data/RP2019_INDCVIZA_csv.zip&quot;, exdir = &quot;data&quot;) Il nous reste plus qu’à charger les données dans notre environnement RStudio : pour cela on utilise la commande fread du package data.table (à installer avant), car cela va bien plus vite que les fonctions habituelles du type read.csv lorsqu’on a de gros fichiers. On indique également l’option stringsAsFactors=TRUE pour que les variables caractères soient directement transformées en variables “factor” (dont l’utilité est indéniable dans R, on en reparlera plus loin), et on transforme l’objet obtenu en data.frame. # install.packages(&quot;data.table&quot;) library(data.table) RP &lt;- fread(&quot;data/FD_INDCVIZA_2019.csv&quot;, stringsAsFactors=TRUE) RP &lt;- as.data.frame(RP) On a donc 88 variables et 4 354 518 observations. Pour se renseigner sur les variables de la table, on peut télécharger également le fichier des métadonnées avec la commande read.csv cette fois, ce qui nous permet de voir quelles options sont utiles ici : l’argument sep = nous permet d’indiquer comment sont séparées les informations dans le fichier initial, l’argument encoding = permet que les accents aigus soient compris par R comme tel, et enfin la même option stringsAsFactors=TRUE peut être utilisée ici. # Lecture du fichier de métadonnées meta &lt;- read.csv(file = &#39;data/Varmod_INDCVI_2019.csv&#39;, sep = &quot;;&quot;, encoding = &quot;UTF-8&quot;, stringsAsFactors = TRUE) On peut enregistrer ce fichier, ainsi que celui contenant les métadonnées, dans le dossier R au format RDS. # Enregistrement des fichiers saveRDS(object = RP, file = &quot;data/indiv2019.Rdata&quot;) saveRDS(object = meta, file = &quot;data/meta.Rdata&quot;) 1.2 Quelles informations intéressantes dans cette base ? On peut regarder plus précisément les variables disponibles dans cette base de données à partir de la table de métadonnées : on peut le faire avec la fonction view() et dans ce cas la table s’affichera dans un nouvel onglet dans votre RStudio ; sinon pour l’afficher sur notre document notebook, on peut utiliser la fonction head() et/ou tail() qui affiche respectivement les premières lignes et les dernières lignes de la table. # view(meta) meta %&gt;% head() %&gt;% gt() #La fonction gt() permet un affichage plus joli pour le document html #xaggvmqruj table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #xaggvmqruj thead, #xaggvmqruj tbody, #xaggvmqruj tfoot, #xaggvmqruj tr, #xaggvmqruj td, #xaggvmqruj th { border-style: none; } #xaggvmqruj p { margin: 0; padding: 0; } #xaggvmqruj .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #xaggvmqruj .gt_caption { padding-top: 4px; padding-bottom: 4px; } #xaggvmqruj .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #xaggvmqruj .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #xaggvmqruj .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xaggvmqruj .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xaggvmqruj .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xaggvmqruj .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #xaggvmqruj .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #xaggvmqruj .gt_column_spanner_outer:first-child { padding-left: 0; } #xaggvmqruj .gt_column_spanner_outer:last-child { padding-right: 0; } #xaggvmqruj .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #xaggvmqruj .gt_spanner_row { border-bottom-style: hidden; } #xaggvmqruj .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #xaggvmqruj .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #xaggvmqruj .gt_from_md > :first-child { margin-top: 0; } #xaggvmqruj .gt_from_md > :last-child { margin-bottom: 0; } #xaggvmqruj .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #xaggvmqruj .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #xaggvmqruj .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #xaggvmqruj .gt_row_group_first td { border-top-width: 2px; } #xaggvmqruj .gt_row_group_first th { border-top-width: 2px; } #xaggvmqruj .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xaggvmqruj .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #xaggvmqruj .gt_first_summary_row.thick { border-top-width: 2px; } #xaggvmqruj .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xaggvmqruj .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xaggvmqruj .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #xaggvmqruj .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #xaggvmqruj .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #xaggvmqruj .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xaggvmqruj .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xaggvmqruj .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #xaggvmqruj .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xaggvmqruj .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #xaggvmqruj .gt_left { text-align: left; } #xaggvmqruj .gt_center { text-align: center; } #xaggvmqruj .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #xaggvmqruj .gt_font_normal { font-weight: normal; } #xaggvmqruj .gt_font_bold { font-weight: bold; } #xaggvmqruj .gt_font_italic { font-style: italic; } #xaggvmqruj .gt_super { font-size: 65%; } #xaggvmqruj .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #xaggvmqruj .gt_asterisk { font-size: 100%; vertical-align: 0; } #xaggvmqruj .gt_indent_1 { text-indent: 5px; } #xaggvmqruj .gt_indent_2 { text-indent: 10px; } #xaggvmqruj .gt_indent_3 { text-indent: 15px; } #xaggvmqruj .gt_indent_4 { text-indent: 20px; } #xaggvmqruj .gt_indent_5 { text-indent: 25px; } COD_VAR LIB_VAR COD_MOD LIB_MOD TYPE_VAR LONG_VAR CANTVILLE Département, canton-ou-ville du lieu de résidence (pseudo-canton) 0101 Ambérieu-en-Bugey (0101) CHAR 5 CANTVILLE Département, canton-ou-ville du lieu de résidence (pseudo-canton) 0102 Attignat (0102) CHAR 5 CANTVILLE Département, canton-ou-ville du lieu de résidence (pseudo-canton) 0103 Valserhône (0103) CHAR 5 CANTVILLE Département, canton-ou-ville du lieu de résidence (pseudo-canton) 0104 Belley (0104) CHAR 5 CANTVILLE Département, canton-ou-ville du lieu de résidence (pseudo-canton) 0105 Bourg-en-Bresse-1 (0105) CHAR 5 CANTVILLE Département, canton-ou-ville du lieu de résidence (pseudo-canton) 0106 Bourg-en-Bresse-2 (0106) CHAR 5 On peut établir la liste des variables en utilisant la fonction levels qui donne les niveaux de la variable “COD_VAR” puisque c’est une variable ‘factor’. levels(meta$COD_VAR) [1] &quot;ACHLR&quot; &quot;AEMMR&quot; &quot;AGED&quot; &quot;AGER20&quot; &quot;AGEREV&quot; &quot;AGEREVQ&quot; [7] &quot;ANAI&quot; &quot;ANEMR&quot; &quot;APAF&quot; &quot;ARM&quot; &quot;ASCEN&quot; &quot;BAIN&quot; [13] &quot;BATI&quot; &quot;CANTVILLE&quot; &quot;CATIRIS&quot; &quot;CATL&quot; &quot;CATPC&quot; &quot;CHAU&quot; [19] &quot;CHFL&quot; &quot;CHOS&quot; &quot;CLIM&quot; &quot;CMBL&quot; &quot;COUPLE&quot; &quot;CS1&quot; [25] &quot;CUIS&quot; &quot;DEPT&quot; &quot;DEROU&quot; &quot;DIPL&quot; &quot;DNAI&quot; &quot;EAU&quot; [31] &quot;EGOUL&quot; &quot;ELEC&quot; &quot;EMPL&quot; &quot;ETUD&quot; &quot;GARL&quot; &quot;HLML&quot; [37] &quot;ILETUD&quot; &quot;ILT&quot; &quot;IMMI&quot; &quot;INAI&quot; &quot;INATC&quot; &quot;INFAM&quot; [43] &quot;INPER&quot; &quot;INPERF&quot; &quot;IPONDI&quot; &quot;IRAN&quot; &quot;IRIS&quot; &quot;LIENF&quot; [49] &quot;LPRF&quot; &quot;LPRM&quot; &quot;METRODOM&quot; &quot;MOCO&quot; &quot;MODV&quot; &quot;NA17&quot; [55] &quot;NA5&quot; &quot;NAIDT&quot; &quot;NBPI&quot; &quot;NE17FR&quot; &quot;NE24FR&quot; &quot;NE3FR&quot; [61] &quot;NE5FR&quot; &quot;NENFR&quot; &quot;NPERR&quot; &quot;NUMF&quot; &quot;NUMMI&quot; &quot;ORIDT&quot; [67] &quot;RECH&quot; &quot;REGION&quot; &quot;SANI&quot; &quot;SANIDOM&quot; &quot;SEXE&quot; &quot;SFM&quot; [73] &quot;STAT_CONJ&quot; &quot;STATR&quot; &quot;STOCD&quot; &quot;SURF&quot; &quot;TACT&quot; &quot;TACTD16&quot; [79] &quot;TP&quot; &quot;TRANS&quot; &quot;TRIRIS&quot; &quot;TYPC&quot; &quot;TYPFC&quot; &quot;TYPL&quot; [85] &quot;TYPMC&quot; &quot;TYPMR&quot; &quot;VOIT&quot; &quot;WC&quot; Les codes des variables n’étant pas très parlant, on va les afficher avec leur intitulé : pour cela, il suffit de repartir de la table meta en sélectionnant les 2 colonnes qui nous intéressent et en n’affichant pas les valeurs dupliquées avec la fonction unique(). meta %&gt;% select(COD_VAR, LIB_VAR) %&gt;% unique() %&gt;% gt() #rjkfslfcry table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #rjkfslfcry thead, #rjkfslfcry tbody, #rjkfslfcry tfoot, #rjkfslfcry tr, #rjkfslfcry td, #rjkfslfcry th { border-style: none; } #rjkfslfcry p { margin: 0; padding: 0; } #rjkfslfcry .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #rjkfslfcry .gt_caption { padding-top: 4px; padding-bottom: 4px; } #rjkfslfcry .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #rjkfslfcry .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #rjkfslfcry .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #rjkfslfcry .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #rjkfslfcry .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #rjkfslfcry .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #rjkfslfcry .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #rjkfslfcry .gt_column_spanner_outer:first-child { padding-left: 0; } #rjkfslfcry .gt_column_spanner_outer:last-child { padding-right: 0; } #rjkfslfcry .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #rjkfslfcry .gt_spanner_row { border-bottom-style: hidden; } #rjkfslfcry .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #rjkfslfcry .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #rjkfslfcry .gt_from_md > :first-child { margin-top: 0; } #rjkfslfcry .gt_from_md > :last-child { margin-bottom: 0; } #rjkfslfcry .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #rjkfslfcry .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #rjkfslfcry .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #rjkfslfcry .gt_row_group_first td { border-top-width: 2px; } #rjkfslfcry .gt_row_group_first th { border-top-width: 2px; } #rjkfslfcry .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #rjkfslfcry .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #rjkfslfcry .gt_first_summary_row.thick { border-top-width: 2px; } #rjkfslfcry .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #rjkfslfcry .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #rjkfslfcry .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #rjkfslfcry .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #rjkfslfcry .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #rjkfslfcry .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #rjkfslfcry .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #rjkfslfcry .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #rjkfslfcry .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #rjkfslfcry .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #rjkfslfcry .gt_left { text-align: left; } #rjkfslfcry .gt_center { text-align: center; } #rjkfslfcry .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #rjkfslfcry .gt_font_normal { font-weight: normal; } #rjkfslfcry .gt_font_bold { font-weight: bold; } #rjkfslfcry .gt_font_italic { font-style: italic; } #rjkfslfcry .gt_super { font-size: 65%; } #rjkfslfcry .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #rjkfslfcry .gt_asterisk { font-size: 100%; vertical-align: 0; } #rjkfslfcry .gt_indent_1 { text-indent: 5px; } #rjkfslfcry .gt_indent_2 { text-indent: 10px; } #rjkfslfcry .gt_indent_3 { text-indent: 15px; } #rjkfslfcry .gt_indent_4 { text-indent: 20px; } #rjkfslfcry .gt_indent_5 { text-indent: 25px; } COD_VAR LIB_VAR CANTVILLE Département, canton-ou-ville du lieu de résidence (pseudo-canton) NUMMI Numéro du ménage dans le canton-ou-ville (anonymisé) ACHLR Période regroupée d'achèvement de la construction de la maison ou de l'immeuble AEMMR Année d'emménagement dans le logement (regroupée) AGED Âge détaillé (en différence de millésimes) AGER20 Âge en années révolues (âge au dernier anniversaire) en 13 classes d'âge, détaillées autour de 20 ans AGEREV Âge en années révolues détaillé AGEREVQ Âge quinquennal en années révolues ANAI Année de naissance ANEMR Ancienneté d'emménagement dans le logement (regroupée) APAF Appartenance à une famille ARM Arrondissement municipal de résidence (Paris, Lyon et Marseille) ARM Arrondissement municipal de résidence (Paris,Lyon et Marseille) ASCEN Desserte par un ascenseur BAIN Baignoire ou douche (DOM) BATI Aspect du bâti (DOM) CATIRIS Catégorie de l'IRIS CATL Catégorie de logement CATPC Catégorie de population condensée CHAU Moyen de chauffage du logement (DOM) CHFL Chauffage central du logement (France métropolitaine) CHOS Chauffe-eau solaire (DOM) CLIM Existence d'au moins une pièce climatisée (DOM) CMBL Combustible principal du logement (France métropolitaine) COUPLE Déclaration de vie en couple CS1 Catégorie socioprofessionnelle en 8 postes CUIS Cuisine intérieure avec évier (DOM) DEPT Département du lieu de résidence DEROU Nombre de deux-roues à moteur du ménage (DOM) DIPL Diplôme le plus élevé DNAI Département de naissance (si né en France) EAU Point d'eau potable à l'intérieur du logement (DOM) EGOUL Mode d'évacuation des eaux usées (DOM) ELEC Électricité dans le logement (DOM) EMPL Condition d'emploi ETUD Inscription dans un établissement d'enseignement GARL Emplacement réservé de stationnement HLML Appartenance du logement à un organisme HLM ILETUD Indicateur du lieu d'études ILT Indicateur du lieu de travail IMMI Situation quant à l'immigration INAI Indicateur du lieu de naissance INATC Indicateur de nationalité condensé (Français/Étranger) INFAM Nombre de familles du ménage INPER Nombre de personnes du ménage INPERF Nombre de personnes de la famille IPONDI Poids de l'individu IRAN Indicateur de résidence antérieure au 1er janvier de l'année précédente IRIS Code IRIS du lieu de résidence LIENF Lien familial LPRF Lien à la personne de référence de la famille LPRM Lien à la personne de référence du ménage METRODOM Indicateur Métropole ou DOM du lieu de résidence MOCO Mode de cohabitation MODV Mode de vie NA17 Activité économique en 17 postes (NA - A17) NA5 Activité économique regroupée en 5 postes NAIDT Naissance dans un DOM-TOM-COM NBPI Nombre de pièces du logement NE17FR Nombre d'enfants âgés de 17 ans ou moins de la famille (regroupé) NE24FR Nombre d'enfants âgés de 24 ans ou moins de la famille (regroupé) NE3FR Nombre d'enfants âgés de 3 ans ou moins de la famille (regroupé) NE5FR Nombre d'enfants âgés de 5 ans ou moins de la famille (regroupé) NENFR Nombre d'enfants de la famille (regroupé) NPERR Nombre de personnes du ménage (regroupé) NUMF Numéro de famille ORIDT Originaire d'un DOM-TOM-COM RECH Ancienneté de recherche d'emploi REGION Région du lieu de résidence SANI Installations sanitaires (France métropolitaine) SANIDOM Installations sanitaires (DOM) SEXE Sexe SFM Structure familiale du ménage STATR Statut professionnel regroupé STAT_CONJ Statut conjugal STOCD Statut d'occupation détaillé du logement SURF Superficie du logement TACT Type d'activité TACTD16 Type d'activité détaillé en 16 postes TP Temps de travail TRANS Mode de transport principal le plus souvent utilisé pour aller travailler TRIRIS Code TRIRIS du lieu de résidence TYPC Type de construction TYPFC Type de famille condensé TYPL Type de logement TYPMC Type de ménage regroupé (en 4 postes) TYPMR Type de ménage regroupé (en 9 postes) VOIT Nombre de voitures du ménage WC Présence de W.-C. à l'intérieur du logement (DOM) Ou si on veut les afficher par ordre alphabétique selon le nom de la variable, on peut utiliser la fonction arrange() qui permet de trier une table de données selon la variable indiquée : meta %&gt;% select(COD_VAR, LIB_VAR) %&gt;% unique() %&gt;% arrange(COD_VAR) %&gt;% gt() L’une des difficultés pour l’analyse de cette base de données réside dans les différents niveaux présents : “individu” pour la personne de référence du ménage ; “ménage” regroupant l’ensemble des occupants d’une résidence principale, qu’ils aient ou non des liens de parenté ; “famille” partie d’un ménage comprenant au moins 2 personnes (par exemple, un couple, ou un adulte avec un enfant…) ; et enfin “logement” qui comprend ici les résidences principales et rassemble des informations décrivant les types de logement. Il faut bien comprendre comment utiliser à bon escient ces différents niveaux, en particulier ici le niveau logement : pour toute variable de ce niveau, il faudra utiliser un filtre, c’est-à-dire ne prendre que la personne de référence du ménage (LPRM==\"1\"). Il faut également penser que les données sont pondérées, donc pour sortir des statistiques descriptives, il faut à chaque fois mettre la variable de pondération IPONDI. "],["02-Manipulation-base.html", "Section 2 Manipulation de la base 2.1 Format des données - WIDE ou LONG 2.2 Sélectionner un champ réduit de la base, séparer les données", " Section 2 Manipulation de la base On peut maintenant regarder à quoi ressemble la table principale, celle des données. RP %&gt;% head() %&gt;% gt() #cmtpzvmtso table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #cmtpzvmtso thead, #cmtpzvmtso tbody, #cmtpzvmtso tfoot, #cmtpzvmtso tr, #cmtpzvmtso td, #cmtpzvmtso th { border-style: none; } #cmtpzvmtso p { margin: 0; padding: 0; } #cmtpzvmtso .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #cmtpzvmtso .gt_caption { padding-top: 4px; padding-bottom: 4px; } #cmtpzvmtso .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #cmtpzvmtso .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #cmtpzvmtso .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #cmtpzvmtso .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #cmtpzvmtso .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #cmtpzvmtso .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #cmtpzvmtso .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #cmtpzvmtso .gt_column_spanner_outer:first-child { padding-left: 0; } #cmtpzvmtso .gt_column_spanner_outer:last-child { padding-right: 0; } #cmtpzvmtso .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #cmtpzvmtso .gt_spanner_row { border-bottom-style: hidden; } #cmtpzvmtso .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #cmtpzvmtso .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #cmtpzvmtso .gt_from_md > :first-child { margin-top: 0; } #cmtpzvmtso .gt_from_md > :last-child { margin-bottom: 0; } #cmtpzvmtso .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #cmtpzvmtso .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #cmtpzvmtso .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #cmtpzvmtso .gt_row_group_first td { border-top-width: 2px; } #cmtpzvmtso .gt_row_group_first th { border-top-width: 2px; } #cmtpzvmtso .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #cmtpzvmtso .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #cmtpzvmtso .gt_first_summary_row.thick { border-top-width: 2px; } #cmtpzvmtso .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #cmtpzvmtso .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #cmtpzvmtso .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #cmtpzvmtso .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #cmtpzvmtso .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #cmtpzvmtso .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #cmtpzvmtso .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #cmtpzvmtso .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #cmtpzvmtso .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #cmtpzvmtso .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #cmtpzvmtso .gt_left { text-align: left; } #cmtpzvmtso .gt_center { text-align: center; } #cmtpzvmtso .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #cmtpzvmtso .gt_font_normal { font-weight: normal; } #cmtpzvmtso .gt_font_bold { font-weight: bold; } #cmtpzvmtso .gt_font_italic { font-style: italic; } #cmtpzvmtso .gt_super { font-size: 65%; } #cmtpzvmtso .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #cmtpzvmtso .gt_asterisk { font-size: 100%; vertical-align: 0; } #cmtpzvmtso .gt_indent_1 { text-indent: 5px; } #cmtpzvmtso .gt_indent_2 { text-indent: 10px; } #cmtpzvmtso .gt_indent_3 { text-indent: 15px; } #cmtpzvmtso .gt_indent_4 { text-indent: 20px; } #cmtpzvmtso .gt_indent_5 { text-indent: 25px; } CANTVILLE NUMMI ACHLR AEMMR AGED AGER20 AGEREV AGEREVQ ANAI ANEMR APAF ARM ASCEN BAIN BATI CATIRIS CATL CATPC CHAU CHFL CHOS CLIM CMBL COUPLE CS1 CUIS DEPT DEROU DIPL DNAI EAU EGOUL ELEC EMPL ETUD GARL HLML ILETUD ILT IMMI INAI INATC INFAM INPER INPERF IPONDI IRAN IRIS LIENF LPRF LPRM METRODOM MOCO MODV NA17 NA5 NAIDT NBPI NE17FR NE24FR NE3FR NE5FR NENFR NPERR NUMF ORIDT RECH REGION SANI SANIDOM SEXE SFM STAT_CONJ STATR STOCD SURF TACT TACTD16 TP TRANS TRIRIS TYPC TYPFC TYPL TYPMC TYPMR VOIT WC 75ZZ 1 1 9 72 79 72 70 1944 02 0 75115 1 Z Z H 1 0 Z 2 Z Z 2 2 7 Z 75 Z 19 2B Z Z Z ZZ 2 1 2 Z Z 2 3 1 0 1 Z 3.360730 1 751155817 0 0 1 M 32 50 ZZ ZZ 0 04 Z Z Z Z Z 1 Z 0 0 11 2 ZZ 2 12 6 Z 10 4 21 210 Z Z 751501 3 Z 1 1 12 1 Z 75ZZ 2 2 9 59 64 58 55 1958 03 1 75112 2 Z Z H 1 0 Z 3 Z Z 4 1 3 Z 75 Z 17 99 Z Z Z 21 2 2 2 Z 1 1 6 1 1 2 2 3.668459 1 751124512 1 1 1 M 21 40 FZ FZ 30 01 0 0 0 0 0 2 1 0 Z 11 1 ZZ 1 30 3 2 21 1 11 116 1 5 750901 3 2 6 4 41 0 Z 75ZZ 2 2 9 30 29 29 25 1987 03 1 75112 2 Z Z H 1 0 Z 3 Z Z 4 1 3 Z 75 Z 16 99 Z Z Z 21 2 2 2 Z 3 1 6 2 1 2 2 3.668459 1 751124512 1 2 2 M 21 31 MN GU 30 01 0 0 0 0 0 2 1 0 Z 11 1 ZZ 1 30 3 2 21 1 11 111 1 6 750901 3 2 6 4 41 0 Z 75ZZ 3 1 7 82 80 81 80 1938 05 2 75115 1 Z Z H 1 0 Z 2 Z Z 2 1 7 Z 75 Z 14 92 Z Z Z ZZ 2 1 2 Z Z 2 2 1 1 2 2 3.478821 1 751155907 2 2 2 M 21 40 ZZ ZZ 0 03 0 0 0 0 0 2 1 0 9 11 2 ZZ 2 30 1 Z 10 4 21 210 Z Z 751431 3 2 2 4 44 1 Z 75ZZ 3 1 7 86 80 85 85 1934 05 1 75115 1 Z Z H 1 0 Z 2 Z Z 2 1 7 Z 75 Z 14 75 Z Z Z ZZ 2 1 2 Z Z 2 1 1 1 2 2 3.478821 1 751155907 1 1 1 M 21 40 ZZ ZZ 0 03 0 0 0 0 0 2 1 0 9 11 2 ZZ 1 30 1 Z 10 4 21 210 Z Z 751431 3 2 2 4 44 1 Z 75ZZ 4 2 9 1 2 0 0 2019 01 3 75116 1 Z Z H 1 0 Z 2 Z Z 2 2 8 Z 75 Z ZZ 92 Z Z Z ZZ 2 1 2 Z Z 2 2 1 1 3 3 2.776887 Z 751166301 3 3 3 M 12 12 ZZ ZZ 0 04 2 2 2 2 2 3 1 0 Z 11 2 ZZ 1 22 6 Z 30 6 23 230 Z Z 751741 3 1 2 3 32 1 Z La fonction str() ou son équivalent en langage dplyr la fonction glimpse nous donne la liste des variables avec cette fois leur format et leurs modalités (les premières seulement s’il y en a beaucoup). # str(RP) RP %&gt;% glimpse() Rows: 4,354,518 Columns: 88 $ CANTVILLE &lt;fct&gt; 75ZZ, 75ZZ, 75ZZ, 75ZZ, 75ZZ, 75ZZ, 75ZZ, 75ZZ, 75ZZ, 75ZZ, … $ NUMMI &lt;fct&gt; 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 7, 7, 7, 7, 8, 9, 10, 10, 1… $ ACHLR &lt;fct&gt; 1, 2, 2, 1, 1, 2, 2, 2, 1, 1, 4, 3, 3, 3, 3, 4, 3, 4, 4, 4, … $ AEMMR &lt;fct&gt; 9, 9, 9, 7, 7, 9, 9, 9, 6, 6, 9, 9, 9, 9, 9, 7, 6, 9, 9, 9, … $ AGED &lt;int&gt; 72, 59, 30, 82, 86, 1, 34, 3, 67, 67, 34, 51, 48, 17, 13, 82… $ AGER20 &lt;int&gt; 79, 64, 29, 80, 80, 2, 39, 2, 79, 79, 39, 54, 54, 17, 14, 80… $ AGEREV &lt;int&gt; 72, 58, 29, 81, 85, 0, 33, 2, 67, 66, 33, 50, 47, 16, 12, 81… $ AGEREVQ &lt;int&gt; 70, 55, 25, 80, 85, 0, 30, 0, 65, 65, 30, 50, 45, 15, 10, 80… $ ANAI &lt;int&gt; 1944, 1958, 1987, 1938, 1934, 2019, 1986, 2017, 1950, 1950, … $ ANEMR &lt;fct&gt; 02, 03, 03, 05, 05, 01, 01, 01, 06, 06, 01, 03, 03, 03, 03, … $ APAF &lt;fct&gt; 0, 1, 1, 2, 1, 3, 2, 3, 1, 2, 0, 1, 2, 3, 3, 0, 0, 3, 2, 3, … $ ARM &lt;fct&gt; 75115, 75112, 75112, 75115, 75115, 75116, 75116, 75116, 7511… $ ASCEN &lt;fct&gt; 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, … $ BAIN &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, … $ BATI &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, … $ CATIRIS &lt;fct&gt; H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, … $ CATL &lt;fct&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … $ CATPC &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … $ CHAU &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, … $ CHFL &lt;fct&gt; 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, … $ CHOS &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, … $ CLIM &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, … $ CMBL &lt;fct&gt; 2, 4, 4, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 1, 1, 1, 1, … $ COUPLE &lt;int&gt; 2, 1, 1, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, … $ CS1 &lt;int&gt; 7, 3, 3, 7, 7, 8, 8, 8, 7, 7, 3, 5, 5, 8, 8, 7, 7, 5, 4, 4, … $ CUIS &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, … $ DEPT &lt;int&gt; 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, … $ DEROU &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, … $ DIPL &lt;fct&gt; 19, 17, 16, 14, 14, ZZ, 18, ZZ, 17, 16, 18, 03, 13, 03, ZZ, … $ DNAI &lt;fct&gt; 2B, 99, 99, 92, 75, 92, 92, 92, 92, 92, 49, 99, 99, 93, 75, … $ EAU &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, … $ EGOUL &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, … $ ELEC &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, … $ EMPL &lt;fct&gt; ZZ, 21, 21, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, 16, 16, 16, ZZ, ZZ, … $ ETUD &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, … $ GARL &lt;fct&gt; 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, … $ HLML &lt;fct&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, … $ ILETUD &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, 1, 1, Z, Z, Z, Z, Z, … $ ILT &lt;fct&gt; Z, 1, 3, Z, Z, Z, Z, Z, Z, Z, 3, 1, 1, Z, Z, Z, Z, 1, 1, Z, … $ IMMI &lt;int&gt; 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, … $ INAI &lt;int&gt; 3, 6, 6, 2, 1, 2, 2, 2, 2, 2, 3, 6, 6, 2, 1, 1, 2, 3, 3, 3, … $ INATC &lt;int&gt; 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … $ INFAM &lt;fct&gt; 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, … $ INPER &lt;fct&gt; 1, 2, 2, 2, 2, 3, 3, 3, 2, 2, 1, 4, 4, 4, 4, 1, 1, 3, 3, 3, … $ INPERF &lt;fct&gt; Z, 2, 2, 2, 2, 3, 3, 3, 2, 2, Z, 4, 4, 4, 4, Z, Z, 3, 3, 3, … $ IPONDI &lt;dbl&gt; 3.360730, 3.668459, 3.668459, 3.478821, 3.478821, 2.776887, … $ IRAN &lt;fct&gt; 1, 1, 1, 1, 1, Z, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … $ IRIS &lt;fct&gt; 751155817, 751124512, 751124512, 751155907, 751155907, 75116… $ LIENF &lt;fct&gt; 0, 1, 1, 2, 1, 3, 2, 3, 1, 2, 0, 1, 2, 3, 3, 0, 0, 3, 2, 3, … $ LPRF &lt;fct&gt; 0, 1, 2, 2, 1, 3, 1, 3, 1, 2, 0, 1, 2, 3, 3, 0, 0, 3, 1, 3, … $ LPRM &lt;fct&gt; 1, 1, 2, 2, 1, 3, 1, 3, 1, 2, 1, 1, 2, 3, 3, 1, 1, 3, 1, 3, … $ METRODOM &lt;fct&gt; M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, … $ MOCO &lt;int&gt; 32, 21, 21, 21, 21, 12, 23, 12, 21, 21, 32, 22, 22, 11, 11, … $ MODV &lt;int&gt; 50, 40, 31, 40, 40, 12, 33, 12, 40, 40, 20, 32, 32, 11, 11, … $ NA17 &lt;fct&gt; ZZ, FZ, MN, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, OQ, MN, MN, ZZ, ZZ, … $ NA5 &lt;fct&gt; ZZ, FZ, GU, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, OQ, GU, GU, ZZ, ZZ, … $ NAIDT &lt;int&gt; 0, 30, 30, 0, 0, 0, 0, 0, 0, 0, 0, 30, 30, 0, 0, 0, 0, 0, 0,… $ NBPI &lt;fct&gt; 04, 01, 01, 03, 03, 04, 04, 04, 08, 08, 01, 03, 03, 03, 03, … $ NE17FR &lt;fct&gt; Z, 0, 0, 0, 0, 2, 2, 2, 0, 0, Z, 2, 2, 2, 2, Z, Z, 0, 0, 0, … $ NE24FR &lt;fct&gt; Z, 0, 0, 0, 0, 2, 2, 2, 0, 0, Z, 2, 2, 2, 2, Z, Z, 1, 1, 1, … $ NE3FR &lt;fct&gt; Z, 0, 0, 0, 0, 2, 2, 2, 0, 0, Z, 0, 0, 0, 0, Z, Z, 0, 0, 0, … $ NE5FR &lt;fct&gt; Z, 0, 0, 0, 0, 2, 2, 2, 0, 0, Z, 0, 0, 0, 0, Z, Z, 0, 0, 0, … $ NENFR &lt;fct&gt; Z, 0, 0, 0, 0, 2, 2, 2, 0, 0, Z, 2, 2, 2, 2, Z, Z, 2, 2, 2, … $ NPERR &lt;fct&gt; 1, 2, 2, 2, 2, 3, 3, 3, 2, 2, 1, 4, 4, 4, 4, 1, 1, 3, 3, 3, … $ NUMF &lt;fct&gt; Z, 1, 1, 1, 1, 1, 1, 1, 1, 1, Z, 1, 1, 1, 1, Z, Z, 1, 1, 1, … $ ORIDT &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … $ RECH &lt;fct&gt; 0, Z, Z, 9, 9, Z, 0, Z, 0, 0, Z, Z, Z, 0, Z, 9, 0, Z, Z, 1, … $ REGION &lt;int&gt; 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, … $ SANI &lt;fct&gt; 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, … $ SANIDOM &lt;fct&gt; ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, ZZ, … $ SEXE &lt;int&gt; 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, … $ SFM &lt;fct&gt; 12, 30, 30, 30, 30, 22, 22, 22, 30, 30, 12, 32, 32, 32, 32, … $ STAT_CONJ &lt;int&gt; 6, 3, 3, 1, 1, 6, 1, 6, 1, 1, 6, 3, 3, 6, 6, 4, 5, 6, 6, 6, … $ STATR &lt;fct&gt; Z, 2, 2, Z, Z, Z, Z, Z, Z, Z, 1, 1, 1, Z, Z, Z, Z, 1, 1, Z, … $ STOCD &lt;fct&gt; 10, 21, 21, 10, 10, 30, 30, 30, 10, 10, 21, 30, 30, 30, 30, … $ SURF &lt;fct&gt; 4, 1, 1, 4, 4, 6, 6, 6, 7, 7, 1, 4, 4, 4, 4, 3, 3, 6, 6, 6, … $ TACT &lt;int&gt; 21, 11, 11, 21, 21, 23, 24, 23, 21, 21, 11, 11, 11, 22, 23, … $ TACTD16 &lt;int&gt; 210, 116, 111, 210, 210, 230, 240, 230, 210, 210, 111, 111, … $ TP &lt;fct&gt; Z, 1, 1, Z, Z, Z, Z, Z, Z, Z, 2, 1, 1, Z, Z, Z, Z, 1, 1, Z, … $ TRANS &lt;fct&gt; Z, 5, 6, Z, Z, Z, Z, Z, Z, Z, 6, 6, 6, Z, Z, Z, Z, 6, 1, Z, … $ TRIRIS &lt;fct&gt; 751501, 750901, 750901, 751431, 751431, 751741, 751741, 7517… $ TYPC &lt;fct&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, … $ TYPFC &lt;fct&gt; Z, 2, 2, 2, 2, 1, 1, 1, 2, 2, Z, 2, 2, 2, 2, Z, Z, 1, 1, 1, … $ TYPL &lt;fct&gt; 1, 6, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, … $ TYPMC &lt;fct&gt; 1, 4, 4, 4, 4, 3, 3, 3, 4, 4, 1, 4, 4, 4, 4, 1, 1, 3, 3, 3, … $ TYPMR &lt;fct&gt; 12, 41, 41, 44, 44, 32, 32, 32, 44, 44, 12, 41, 41, 41, 41, … $ VOIT &lt;fct&gt; 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, … $ WC &lt;fct&gt; Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, … Les variables sont en format, soit ‘int’ (“integer” - nombres entiers), soit ‘fct’ (“factor”), ou encore ‘dbl’ (“double” - nombres réels). On remarque que la plupart des variables ont des modalités en chiffres et/ou lettres, ce qui signifie qu’il faudra probablement recoder ces modalités pour leur donner des libellés dans nos analyses descriptives (tableaux ou graphiques). Par ailleurs, certaines variables ont été laissées en format ‘integer’ bien que l’on avait mis l’option stringsAsFactors=TRUE lors du chargement des données, or ces chiffres correspondent bien à des modalités d’une variable catégorielle, il faudra donc le corriger ultérieurement. Dernière remarque, si on avait eu des valeurs manquantes sur certaines variables, elles se seraient ici affichées avec la modalité NA, cela ne semble pas le cas, à vérifier par la suite. En revanche, on voit parfois des modalités “z” ou “zz”, il faudra vérifier ce qu’elles indiquent. 2.1 Format des données - WIDE ou LONG La question du format de la table de données est importante, on distingue généralement le format wide du format long : le premier renvoie au cas où chaque ligne correspond a un et un seul individu (ou autre niveau de l’analyse : une entreprise, un ménage, un logement, etc.), et toutes les informations le concernant sont données en colonnes (ce qui peut augmenter rapidement le nombre de colonnes), c’est l’exemple d’une information que l’on a sur plusieurs années, chaque colonne correspondant à l’information de l’année en question ; le second, au contraire, multiplie les lignes pour un seul individu, mais il y a alors moins de colonnes, à partir du même exemple précédent, il y aura cette fois une colonne indiquant l’année et une colonne contenant l’information. Ici, chaque ligne correspond à un individu auquel est associé un logement, un ménage ou encore une famille ; on est bien dans un format wide. L’unité statistique de base est donc l’individu, mais on peut vouloir choisir de se mettre au niveau logement ou ménage ou famille, pour étudier les caractéristiques de ces unités. Autre exemple, on peut aussi considérer que notre niveau d’analyse est la commune, on verra alors qu’on dispose de plusieurs lignes par commune et si l’on veut garder quelques informations à ce niveau en n’ayant plus qu’une ligne par commune, il faudra sommer ces informations. Le package tidyverse contient deux fonctions qui permettent de passer d’un format à un autre : pivot_longer() et pivot_wider() présentés en détails ici. Nous aurons l’occasion de les utiliser ultérieurement dans ce cours. 2.2 Sélectionner un champ réduit de la base, séparer les données Manipuler une base de données, c’est aussi travailler ou créer une table réduite, surtout quand on a des données volumineuses comme ici : c’est donc choisir un champ particulier de la base. On peut par exemple choisir un champ géographique plus réduit au sein de l’Île-de-France, à partir de la commune : Paris et sa petite couronne. On peut aussi choisir de séparer les données en créant 2 tables selon l’unité statistique : l’individu ; ou le logement avec la seule personne de référence du ménage. Comme vous le savez très probablement, dans le langage tidyverse, pour faire des sélections sur les lignes ou observations dans une table de données, on utilise la fonction filter() ; pour faire des sélections sur les colonnes ou variables, on utilise la fonction select() ; pour supprimer des variables, on utilise également select() avec un “-” devant la (ou les) variable(s) à supprimer (dans le langage R de base, on peut aussi utiliser la fonction subset()). EXERCICES : Créer trois nouvelles bases selon les indications suivantes : la première que vous nommerez “RP_Paris” et qui rassemblera les données pour le seul département de Paris ; la deuxième que nous nommerez “RP_indiv” et qui comprendra les données pour les seules variables décrivant l’individu (et ce sera celle de la personne de référence du ménage) ; la troisième que vous nommerez “RP_final”, qui rassemblera les données pour les départements de Paris et de sa petite couronne, et qui comprendra toutes les variables décrivant l’individu, le logement et enfin les variables géographiques. RP_Paris &lt;- RP %&gt;% filter(DEPT == &quot;75&quot;) RP_indiv &lt;- RP %&gt;% select(&quot;AEMMR&quot;, &quot;AGED&quot;, &quot;AGER20&quot;, &quot;AGEREV&quot;,&quot;AGEREVQ&quot;,&quot;ANAI&quot;, &quot;ANEMR&quot;,&quot;APAF&quot;,&quot;COUPLE&quot;,&quot;CS1&quot;,&quot;DIPL&quot;,&quot;DNAI&quot;,&quot;EMPL&quot;, &quot;ETUD&quot;,&quot;ILETUD&quot;,&quot;ILT&quot;,&quot;IMMI&quot;,&quot;INAI&quot;,&quot;INATC&quot;,&quot;IPONDI&quot;, &quot;IRAN&quot;,&quot;LPRF&quot;,&quot;LPRM&quot;,&quot;MOCO&quot;,&quot;MODV&quot;,&quot;NA17&quot;, &quot;NA5&quot;,&quot;NAIDT&quot;,&quot;ORIDT&quot;,&quot;RECH&quot;,&quot;SEXE&quot;,&quot;STAT_CONJ&quot;, &quot;STATR&quot;,&quot;TACT&quot;,&quot;TACTD16&quot;,&quot;TP&quot;,&quot;TRANS&quot;) RP_final &lt;- RP %&gt;% filter(DEPT %in% c(&quot;75&quot;,&quot;92&quot;,&quot;93&quot;,&quot;94&quot;)) %&gt;% select(-c(&quot;NUMMI&quot;,&quot;INPERF&quot;,&quot;DEROU&quot;,&quot;LIENF&quot;,&quot;INFAM&quot;, &quot;NE17FR&quot;,&quot;INPER&quot;, &quot;NE24FR&quot;,&quot;NPERR&quot;, &quot;NE3FR&quot;, &quot;SFM&quot;, &quot;NE5FR&quot;, &quot;TYPMC&quot;, &quot;NENFR&quot;,&quot;TYPMR&quot;, &quot;NUMF&quot;,&quot;VOIT&quot;, &quot;TYPFC&quot;)) On va dorénavant travailler sur cette dernière table RP_final, on l’enregistre donc dans notre dossier “data”, ainsi que le fichier meta que nous avonhs modifié précédemments : # Enregistrement des fichiers saveRDS(object = RP_final , file = &quot;data/RP_final.Rdata&quot;) saveRDS(object = meta, file = &quot;data/meta.Rdata&quot;) "],["03-Manipulation-variables.html", "Section 3 Manipulation des variables 3.1 Manipulation des variables qualitatives 3.2 Manipulation des variables quantitatives", " Section 3 Manipulation des variables Dans la manipulation des variables, l’une des premières choses à réaliser est de les définir dans le bon format, variables quantitatives/continues ou variables qualitatives/catégorielles. On l’a vu dans la section précédente, certaines variables sont encore codées comme des nombres entiers (“integer”) alors que ce sont des variables catégorielles. On va donc corriger cela en regardant d’abord quelles variables sont concernées, en les sélectionnant avec select_if() ou select(where()) : RP_final %&gt;% select_if(is.numeric) %&gt;% names() [1] &quot;AGED&quot; &quot;AGER20&quot; &quot;AGEREV&quot; &quot;AGEREVQ&quot; &quot;ANAI&quot; &quot;CATPC&quot; [7] &quot;COUPLE&quot; &quot;CS1&quot; &quot;DEPT&quot; &quot;ETUD&quot; &quot;IMMI&quot; &quot;INAI&quot; [13] &quot;INATC&quot; &quot;IPONDI&quot; &quot;MOCO&quot; &quot;MODV&quot; &quot;NAIDT&quot; &quot;ORIDT&quot; [19] &quot;REGION&quot; &quot;SEXE&quot; &quot;STAT_CONJ&quot; &quot;TACT&quot; &quot;TACTD16&quot; A part les variables d’âge AGED et AGEREV, de date de naissance ANAI et de pondération IPONDI, toutes les autres variables devraient en format “factor”. Deux façons de les transformer, soit vous changer les variables une à une en utilisant les fonctions mutate() et as.factor() ; soit vous créer une liste avec le nom des variables dont le format doit être transformer et vous utilisez la fonction lapply() en l’appliquant à cette liste de variables : RP_final &lt;- RP_final %&gt;% mutate(AGER20=as.factor(AGER20), AGEREVQ=as.factor(AGEREVQ), CATPC=as.factor(CATPC), COUPLE=as.factor(COUPLE), CS1=as.factor(CS1), DEPT=as.factor(DEPT), ETUD=as.factor(ETUD), IMMI=as.factor(IMMI), INAI=as.factor(INAI), INATC=as.factor(INATC), MOCO=as.factor(MOCO), MODV=as.factor(MODV), NAIDT=as.factor(NAIDT), ORIDT=as.factor(ORIDT), REGION=as.factor(REGION), SEXE=as.factor(SEXE), STAT_CONJ=as.factor(STAT_CONJ), TACT=as.factor(TACT), TACTD16=as.factor(TACTD16)) # 2nde méthode # list_var &lt;- c(&quot;AGER20&quot;, &quot;AGEREVQ&quot;, &quot;CATPC&quot;, &quot;COUPLE&quot;, &quot;CS1&quot;, &quot;DEPT&quot;, &quot;ETUD&quot;, &quot;IMMI&quot;, &quot;INAI&quot;, &quot;INATC&quot;, # &quot;MOCO&quot;, &quot;MODV&quot;, &quot;NAIDT&quot;, &quot;REGION&quot;, &quot;SEXE&quot;, &quot;STAT_CONJ&quot;, &quot;TACT&quot;, &quot;TACTD16&quot;) # RP_final[, list_var] &lt;- lapply(RP_final[, list_var], factor) On peut ensuite vérifier que ces variables sont bien des variables facteurs en regardant combien de modalités elles ont et quelles sont-elles. Par exemple, pour la variable CATPC : nlevels(RP_final$CATPC) [1] 3 levels(RP_final$CATPC) [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; Si nous n’avions pas mis l’option transformant les variables caractères en variables facteurs lors du chargement des données, nous pourrions le faire maintenant en utilisant la fonction mutate_if ou la combinaison de mutate et across(where()) comme ceci RP %&gt;% mutate_if(is.character, as.factor) ou RP %&gt;% mutate(across(where(is.character), as.factor)). On peut enfin vérifier quelles sont les variables numériques qui restent : # RP_final %&gt;% select_if(is.numeric) %&gt;% head() %&gt;% gt() RP_final %&gt;% select(where(is.numeric)) %&gt;% head() %&gt;% gt() #orrqbhpyfn table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #orrqbhpyfn thead, #orrqbhpyfn tbody, #orrqbhpyfn tfoot, #orrqbhpyfn tr, #orrqbhpyfn td, #orrqbhpyfn th { border-style: none; } #orrqbhpyfn p { margin: 0; padding: 0; } #orrqbhpyfn .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #orrqbhpyfn .gt_caption { padding-top: 4px; padding-bottom: 4px; } #orrqbhpyfn .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #orrqbhpyfn .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #orrqbhpyfn .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #orrqbhpyfn .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #orrqbhpyfn .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #orrqbhpyfn .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #orrqbhpyfn .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #orrqbhpyfn .gt_column_spanner_outer:first-child { padding-left: 0; } #orrqbhpyfn .gt_column_spanner_outer:last-child { padding-right: 0; } #orrqbhpyfn .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #orrqbhpyfn .gt_spanner_row { border-bottom-style: hidden; } #orrqbhpyfn .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #orrqbhpyfn .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #orrqbhpyfn .gt_from_md > :first-child { margin-top: 0; } #orrqbhpyfn .gt_from_md > :last-child { margin-bottom: 0; } #orrqbhpyfn .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #orrqbhpyfn .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #orrqbhpyfn .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #orrqbhpyfn .gt_row_group_first td { border-top-width: 2px; } #orrqbhpyfn .gt_row_group_first th { border-top-width: 2px; } #orrqbhpyfn .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #orrqbhpyfn .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #orrqbhpyfn .gt_first_summary_row.thick { border-top-width: 2px; } #orrqbhpyfn .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #orrqbhpyfn .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #orrqbhpyfn .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #orrqbhpyfn .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #orrqbhpyfn .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #orrqbhpyfn .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #orrqbhpyfn .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #orrqbhpyfn .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #orrqbhpyfn .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #orrqbhpyfn .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #orrqbhpyfn .gt_left { text-align: left; } #orrqbhpyfn .gt_center { text-align: center; } #orrqbhpyfn .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #orrqbhpyfn .gt_font_normal { font-weight: normal; } #orrqbhpyfn .gt_font_bold { font-weight: bold; } #orrqbhpyfn .gt_font_italic { font-style: italic; } #orrqbhpyfn .gt_super { font-size: 65%; } #orrqbhpyfn .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #orrqbhpyfn .gt_asterisk { font-size: 100%; vertical-align: 0; } #orrqbhpyfn .gt_indent_1 { text-indent: 5px; } #orrqbhpyfn .gt_indent_2 { text-indent: 10px; } #orrqbhpyfn .gt_indent_3 { text-indent: 15px; } #orrqbhpyfn .gt_indent_4 { text-indent: 20px; } #orrqbhpyfn .gt_indent_5 { text-indent: 25px; } AGED AGEREV ANAI IPONDI 72 72 1944 3.360730 59 58 1958 3.668459 30 29 1987 3.668459 82 81 1938 3.478821 86 85 1934 3.478821 1 0 2019 2.776887 Plus généralement, il est souvent d’usage d’utiliser la fonction summary() pour donner un aperçu de l’ensemble des variables, soit de leur distribution pour les variables quantitatives, soit de leur répartition par modalités pour les variables qualitatives ; la fonction permet également de nous donner l’information sur l’existence et le nombre de valeurs manquantes pour chaque variable. summary(RP_final) CANTVILLE ACHLR AEMMR AGED 75ZZ : 853167 3 :687155 9 :2032861 Min. : 0.00 9296 : 47490 4 :656626 8 : 286192 1st Qu.: 21.00 9398 : 43375 2 :314367 7 : 146463 Median : 36.00 9399 : 43104 1 :303570 6 : 91377 Mean : 38.44 9499 : 37585 6 :301595 Z : 34562 3rd Qu.: 55.00 9299 : 36678 5 :270547 5 : 30169 Max. :120.00 (Other):1574634 (Other):102173 (Other): 14409 AGER20 AGEREV AGEREVQ ANAI 54 :515753 Min. : 0.0 25 : 226438 Min. :1896 39 :412404 1st Qu.: 20.0 30 : 214781 1st Qu.:1963 64 :273384 Median : 36.0 35 : 197623 Median :1981 79 :263157 Mean : 37.5 20 : 186496 Mean :1980 29 :226438 3rd Qu.: 54.0 40 : 181466 3rd Qu.:1997 24 :186496 Max. :119.0 0 : 177322 Max. :2020 (Other):758401 (Other):1451907 ANEMR APAF ARM ASCEN BAIN 01 :655689 3 :777547 ZZZZZ :1782866 1:1460332 X: 34562 03 :564056 0 :643516 75115 : 90717 2:1141139 Z:2601471 02 :542791 2 :620004 75118 : 78739 Z: 34562 00 :317238 1 :539040 75120 : 75863 04 :256066 Z : 34562 75119 : 73388 05 :140210 6 : 8547 75113 : 70196 (Other):159983 (Other): 12817 (Other): 464264 BATI CATIRIS CATL CATPC CHAU CHFL X: 34562 A: 29884 1:2601471 0:2601471 X: 34562 1:1370090 Z:2601471 D: 1488 Z: 34562 1: 26328 Z:2601471 2: 654195 H:2597963 2: 8234 3: 563224 X: 988 4: 13962 Z: 5710 X: 34562 CHOS CLIM CMBL COUPLE CS1 CUIS X: 34562 X: 34562 1: 583799 1:1091726 8 :903563 X: 34562 Z:2601471 Z:2601471 2:1060384 2:1544307 3 :457534 Z:2601471 3: 117844 7 :374763 4: 764429 5 :343737 5: 7861 4 :323394 6: 67154 6 :162434 X: 34562 (Other): 70608 DEPT DIPL DNAI EAU EGOUL 75:853167 18 :486255 99 :716703 X: 34562 X: 34562 92:621663 ZZ :465748 75 :538277 Z:2601471 Z:2601471 93:629049 17 :280471 92 :262709 94:532154 13 :252762 93 :241894 14 :252350 94 :185218 16 :197267 78 : 37782 (Other):701180 (Other):653450 ELEC EMPL ETUD GARL HLML X: 34562 ZZ :1432384 1: 689558 1:1286127 1: 784089 Z:2601471 16 : 913146 2:1946475 2:1315344 2:1817382 15 : 104235 Z: 34562 Z: 34562 21 : 86275 22 : 48699 11 : 25485 (Other): 25809 ILETUD ILT IMMI INAI INATC Z :1946475 Z :1432384 1: 614842 1:738724 1:2180430 1 : 484682 3 : 533246 2:2021191 2:614762 2: 455603 3 : 114507 1 : 449857 3:518740 2 : 76273 2 : 204924 4: 45574 4 : 13812 4 : 12853 5: 1530 5 : 167 7 : 2524 6:716703 (Other): 117 (Other): 245 IPONDI IRAN IRIS LPRF Min. : 0.000 1 :2305666 920120303: 6961 0:643516 1st Qu.: 1.103 2 : 112053 ZZZZZZZZZ: 5710 1:654441 Median : 2.933 4 : 69107 930700109: 5523 2:517420 Mean : 2.596 3 : 40599 751187110: 4104 3:762238 3rd Qu.: 3.404 Z : 38020 920360501: 3818 4: 17410 Max. :30.057 5 : 34401 751176714: 3807 5: 6446 (Other): 36187 (Other) :2606110 Z: 34562 LPRM METRODOM MOCO MODV 1 :1209833 M:2636033 22 :585580 32 :585580 3 : 763890 11 :569579 11 :569579 2 : 513339 32 :526421 50 :321174 8 : 38136 21 :449260 40 :291436 Z : 34562 12 :216515 12 :216515 6 : 32123 23 :137021 20 :205247 (Other): 44150 (Other):151657 (Other):446502 NA17 NA5 NAIDT NBPI ZZ :1432384 AZ: 626 0 :1872226 03 :773582 OQ : 316215 BE: 68660 30 : 716703 04 :628152 MN : 223963 FZ: 50464 11 : 18616 02 :491816 GZ : 129585 GU: 767684 12 : 16979 05 :284228 JZ : 101100 OQ: 316215 14 : 5933 01 :263674 KZ : 78928 ZZ:1432384 13 : 3526 06 : 97433 (Other): 353858 (Other): 2050 (Other): 97148 ORIDT RECH REGION SANI SANIDOM 0 :2570233 0: 595136 11:2636033 0: 17248 XX: 34562 11 : 26547 1: 99394 1: 148161 ZZ:2601471 12 : 23668 2: 81634 2:2436062 14 : 8155 9: 189296 X: 34562 13 : 4671 Z:1670573 18 : 908 (Other): 1851 SEXE STAT_CONJ STATR STOCD SURF TACT 1:1263098 1: 806273 1:1067681 10:992691 4 :736488 11:1203649 2:1372935 2: 90782 2: 135968 21:627380 3 :583150 12: 179713 3: 229555 Z:1432384 22:757862 5 :440798 21: 382445 4: 101992 23:151152 1 :239343 22: 240715 5: 137488 30: 72386 2 :233363 23: 465748 6:1269943 ZZ: 34562 6 :189749 24: 64030 (Other):213142 25: 99733 TACTD16 TP TRANS TRIRIS TYPC 111 :1127202 1:1026823 1: 39223 ZZZZZZ : 47639 1: 259226 230 : 465748 2: 176826 2: 102898 931411 : 10563 2: 194433 210 : 382445 Z:1432384 3: 40772 920331 : 8408 3:2124270 220 : 240715 4: 44362 931071 : 8032 4: 22451 122 : 127564 5: 311836 940721 : 7834 5: 1091 250 : 99733 6: 664558 921011 : 7686 Z: 34562 (Other): 192626 Z:1432384 (Other):2545871 TYPL WC COM 1: 330946 X: 34562 Length:2636033 2:2220098 Z:2601471 Class :character 3: 25394 Mode :character 4: 15607 5: 1942 6: 7484 Z: 34562 Mais attention, le problème ici est que cela nous donne des fréquences non pondérées pour l’ensemble de nos variables qualitatives, donc qui n’ont finalement pas grand sens. 3.1 Manipulation des variables qualitatives On peut d’abord travailler sur les variables qualitatives qui correspondent ici à l’essentiel de nos variables. Comme on le sait, on peut regarder les différents niveaux pour chacune d’entre elles, avec la fonction levels(). Si on veut appliquer la fonction à l’ensemble de nos variables facteurs sans avoir donc à les indiquer une par une, on peut avoir recours à la fonction sapply() qui permet d’appliquer la fonction indiquée entre parenthèses (ici levels()) à tous les éléments de notre table de données. # Pour info, ici cela s&#39;écrirait : RP_final %&gt;% select(where(is.factor)) %&gt;% sapply(levels) # on peut même se passer de la sélection sur les variables : # RP %&gt;% sapply(levels) On peut ensuite vouloir retravailler les modalités de ces variables, car par exemple les modalités ne sont pas parlantes puisque nommées par des codes chiffres, ou parce que les modalités sont trop nombreuses et qu’on souhaiterait les rassembler pour une analyse ultérieure. Par exemple, si l’on veut étudier la répartition de la population francilienne selon leur statut d’activité, on peut utiliser la variable TACT: levels(RP_final$TACT) [1] &quot;11&quot; &quot;12&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; &quot;25&quot; Mais le moins qu’on puisse dire c’est que les 7 modalités de cette variable ne sont pas parlantes, on peut donc recoder les modalités de cette variable dans une étape préalable DATA comme ici ; on pourra bien sûr enchaîner plus tard les lignes de codes et réaliser cette étape dans une même procédure avec le tableau ou le graphique représentant cette variable. Commençons ici par l’étape DATA : # On cherche à quoi correspondent les modalités chiffrées de cette variable # dans le fichier &quot;meta&quot; meta %&gt;% filter(COD_VAR==&quot;TACT&quot;) %&gt;% select(COD_MOD, LIB_MOD) # A tibble: 7 × 2 COD_MOD LIB_MOD &lt;fct&gt; &lt;fct&gt; 1 11 Actifs ayant un emploi, y compris sous apprentissage ou en stage rému… 2 12 Chômeurs 3 21 Retraités ou préretraités 4 22 Élèves, étudiants, stagiaires non rémunéré de 14 ans ou plus 5 23 Moins de 14 ans 6 24 Femmes ou hommes au foyer 7 25 Autres inactifs # On recode à partir de ces libellés, tout en regroupant certaines modalités # qui sont très spécifiques et nous intéressent moins : RP_final &lt;- RP_final %&gt;% mutate(TACT_moda = as.factor( case_when(TACT == &quot;11&quot; ~ &quot;Actifs en emploi&quot;, TACT == &quot;12&quot; ~ &quot;Chômeurs&quot;, TACT == &quot;21&quot; ~ &quot;Retraités&quot;, TACT %in% c(&quot;22&quot;,&quot;23&quot;,&quot;24&quot;,&quot;25&quot;) ~ &quot;Autres inactifs&quot;))) levels(RP_final$TACT_moda) [1] &quot;Actifs en emploi&quot; &quot;Autres inactifs&quot; &quot;Chômeurs&quot; &quot;Retraités&quot; Si l’on veut changer l’ordre des modalités, qui s’afficheront comme ci-dessus dans un tableau ou un graphique, on peut utiliser la fonction fct_relevel() du package forcats (à installer avant puis à appeler avant de l’utiliser) : # install.package(&quot;forcats&quot;) library(forcats) RP_final &lt;- RP_final %&gt;% mutate(TACT_moda = fct_relevel(TACT_moda, c(&quot;Actifs en emploi&quot;,&quot;Chômeurs&quot;, &quot;Retraités&quot;, &quot;Autres inactifs&quot;))) levels(RP_final$TACT_moda) [1] &quot;Actifs en emploi&quot; &quot;Chômeurs&quot; &quot;Retraités&quot; &quot;Autres inactifs&quot; Plus largement, pour travailler sur des variables qualitatives en particulier lorsqu’elles sont en format facteur, le package forcats est très utile. Outre une fonction de transformation d’une variable caractère en facteur (as_factor() proche de la version de baseR as.factor() utilisée en début de section), elle contient plein d’autres fonctions : fct_collapse() utilisée pour renommer ou regrouper des modalités d’une variable (au lieu de la double fonction as.factor() et case_when()) ; fct_relevel() utilisée également au-dessus pour trier les modalités comme on le souhaite ; fct_drop() pour enlever des niveaux de facteurs vides/sans effectifs ; fct_explicit_na() pour rendre les NA explicites en créant une modalité “(missing)” ; fct_reorder() et fct_reorder2() pour réordonner les modalités d’une variable, très utile pour les graphiques car utilisables directement dans ggplot() ; fct_lump() pour regrouper les modalités les plus communes (ou au contraire les moins communes) en lui indiquant entre parenthèses le nombre n= de modalités souhaitées ou la proportion minimum souhaitée prop=, et en sélectionnant la variable avec la fonction pull() avant car elle doit être en format vecteur et non data.frame ; ou encore fct_recode() pour changer le niveau des facteurs ; fct_other() ; fct_infreq() et fct_inorder() ; etc. Un bon récapitulatif de ces fonctions est présenté ici. 3.2 Manipulation des variables quantitatives Comme nous l’avons vu plus haut, il y a peu de variables quantitatives dans cette base et l’une d’entre elles est la pondération, donc on va regarder plus précisément la variable AGED. Cependant, celle-ci aussi est particulière car c’est une variable numérique constituée d’entiers naturels (et non de valeurs réelles) qui vont de 0 à 120 ; dans le fichier des métadonnées (ou le dictionnaire des variables disponible également sur le site de l’Insee), on se rend compte que la variable a été pensée comme catégorielle avec des modalités d’abord codées comme “000”, “001”, etc. meta %&gt;% filter(COD_VAR==&quot;AGED&quot;) %&gt;% select(COD_MOD, LIB_MOD) %&gt;% tail() # A tibble: 6 × 2 COD_MOD LIB_MOD &lt;fct&gt; &lt;fct&gt; 1 115 115 ans 2 116 116 ans 3 117 117 ans 4 118 118 ans 5 119 119 ans 6 120 120 ans On peut alors regarder rapidement la distribution de cette variable. summary(RP_final$AGED) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 21.00 36.00 38.44 55.00 120.00 On peut aussi construire des variables continues en agrégeant certaines informations au niveau des communes par exemple. Reprenons la variable d’activité dont nous avons recoder et regrouper les modalités et calculons-là pour avoir le nombre de chaque modalité par commune. Il faut pour cela créer la variable de commune, qu’on appelera COM, à partir de l’IRIS : RP_final &lt;- RP_final %&gt;% mutate(COM=substr(IRIS, 1, 5)) On va ensuite sommer chaque modalité de la variable TACT_moda en utilisant la pondération en groupant par commune. EXERCICE : Créer donc un tableau qui aura 3 colonnes COM, TACT_moda et n. Vous pouvez utiliser les fonctions group_by suivi soit de count, soit de summarise ; on cherchera finalement à arrondir ces valeurs à l’unité avec la fonction round(). Vous devez obtenir le tableau suivant : Tab_com_TACT &lt;- RP_final %&gt;% group_by(COM) %&gt;% count(TACT_moda, wt=IPONDI) %&gt;% mutate(n=round(n)) # RP_final %&gt;% group_by(COM, TACT_moda) %&gt;% # summarise(n=sum(IPONDI)) %&gt;% # mutate(n=round(n)) On voit qu’on a un tableau dans un format “long” puisqu’il y a plusieurs observations pour une seule commune. On va utiliser la fonction pivot_wider() mentionnée précédemment pour n’avoir qu’une ligne par commune et en colonne les types de statut avec leur nombre respectif. Tab_com_TACT &lt;- Tab_com_TACT %&gt;% pivot_wider(names_from = TACT_moda, values_from = n) Tab_com_TACT # A tibble: 137 × 5 COM `Actifs en emploi` Chômeurs Retraités `Autres inactifs` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 75101 8366 941 2630 3979 2 75102 13118 1378 2148 4964 3 75103 19239 2085 4589 8123 4 75104 15227 1863 4508 7513 5 75105 27378 2611 10607 17618 6 75106 18073 1842 8180 12176 7 75107 23394 2165 9573 13735 8 75108 18254 1565 5297 10534 9 75109 34155 3482 7264 15125 10 75110 46454 6343 10645 23078 # ℹ 127 more rows 3.2.1 Détecter et “visualiser” les valeurs manquantes Pour travailler sur les valeurs manquantes et valeurs aberrantes de variables quantitatives, on va s’appuyer sur une autre base de données, plus pertinente pour cela. Vous la trouverez sur l’espace de cours sur Moodle : il s’agit d’une extraction de la base des données de valeurs foncières pour le seul département de Paris et la vente d’appartements entre 2019 et 2022. Une fois copiée dans le dossier “data/” de notre projet, ouvrons cette base de données et commençons l’exploration des variables de cette base et de leurs valeurs manquantes : dvf_Paris &lt;- readRDS(file =&quot;data/dvf_Paris.Rdata&quot;) dvf_Paris %&gt;% head() %&gt;% gt() #zbiuztjmnb table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #zbiuztjmnb thead, #zbiuztjmnb tbody, #zbiuztjmnb tfoot, #zbiuztjmnb tr, #zbiuztjmnb td, #zbiuztjmnb th { border-style: none; } #zbiuztjmnb p { margin: 0; padding: 0; } #zbiuztjmnb .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #zbiuztjmnb .gt_caption { padding-top: 4px; padding-bottom: 4px; } #zbiuztjmnb .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #zbiuztjmnb .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #zbiuztjmnb .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #zbiuztjmnb .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #zbiuztjmnb .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #zbiuztjmnb .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #zbiuztjmnb .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #zbiuztjmnb .gt_column_spanner_outer:first-child { padding-left: 0; } #zbiuztjmnb .gt_column_spanner_outer:last-child { padding-right: 0; } #zbiuztjmnb .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #zbiuztjmnb .gt_spanner_row { border-bottom-style: hidden; } #zbiuztjmnb .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #zbiuztjmnb .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #zbiuztjmnb .gt_from_md > :first-child { margin-top: 0; } #zbiuztjmnb .gt_from_md > :last-child { margin-bottom: 0; } #zbiuztjmnb .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #zbiuztjmnb .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #zbiuztjmnb .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #zbiuztjmnb .gt_row_group_first td { border-top-width: 2px; } #zbiuztjmnb .gt_row_group_first th { border-top-width: 2px; } #zbiuztjmnb .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #zbiuztjmnb .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #zbiuztjmnb .gt_first_summary_row.thick { border-top-width: 2px; } #zbiuztjmnb .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #zbiuztjmnb .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #zbiuztjmnb .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #zbiuztjmnb .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #zbiuztjmnb .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #zbiuztjmnb .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #zbiuztjmnb .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #zbiuztjmnb .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #zbiuztjmnb .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #zbiuztjmnb .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #zbiuztjmnb .gt_left { text-align: left; } #zbiuztjmnb .gt_center { text-align: center; } #zbiuztjmnb .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #zbiuztjmnb .gt_font_normal { font-weight: normal; } #zbiuztjmnb .gt_font_bold { font-weight: bold; } #zbiuztjmnb .gt_font_italic { font-style: italic; } #zbiuztjmnb .gt_super { font-size: 65%; } #zbiuztjmnb .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #zbiuztjmnb .gt_asterisk { font-size: 100%; vertical-align: 0; } #zbiuztjmnb .gt_indent_1 { text-indent: 5px; } #zbiuztjmnb .gt_indent_2 { text-indent: 10px; } #zbiuztjmnb .gt_indent_3 { text-indent: 15px; } #zbiuztjmnb .gt_indent_4 { text-indent: 20px; } #zbiuztjmnb .gt_indent_5 { text-indent: 25px; } id_mutation date_mutation nature_mutation valeur_fonciere code_postal id_parcelle lot1_numero lot1_surface_carrez lot2_numero lot2_surface_carrez lot3_numero lot3_surface_carrez lot4_numero lot4_surface_carrez lot5_numero lot5_surface_carrez nombre_lots type_local surface_reelle_bati nombre_pieces_principales surface_terrain px_m2 annee date_moisan 2022-1621602 2022-01-04 Vente 580000 75018 75118000BR0026 55 61.00 58 NA 8 NA NA NA NA NA 3 Appartement 25 2 NA 23200.00 2022 2022-01 2022-1621602 2022-01-04 Vente 580000 75018 75118000BR0026 25 NA 56 61.00 NA NA NA NA NA NA 2 Appartement 20 2 NA 29000.00 2022 2022-01 2022-1621603 2022-01-06 Vente 605000 75003 75103000AH0072 7 40.66 NA NA NA NA NA NA NA NA 1 Appartement 42 3 NA 14404.76 2022 2022-01 2022-1621606 2022-01-05 Vente 716250 75009 75109000AC0148 24 NA 3 66.26 38 NA NA NA NA NA 3 Appartement 69 3 NA 10380.43 2022 2022-01 2022-1621607 2022-01-05 Vente 320000 75010 75110000AG0047 27 NA 92 35.19 NA NA NA NA NA NA 2 Appartement 33 2 NA 9696.97 2022 2022-01 2022-1621608 2022-01-07 Vente 320000 75020 75120000AX0021 298 32.52 50 NA NA NA NA NA NA NA 2 Appartement 29 1 NA 11034.48 2022 2022-01 summary(dvf_Paris) id_mutation date_mutation nature_mutation valeur_fonciere Length:178526 Min. :2019-01-02 Length:178526 Min. : 0 Class :character 1st Qu.:2020-05-18 Class :character 1st Qu.: 285000 Mode :character Median :2021-06-11 Mode :character Median : 480000 Mean :2021-03-14 Mean : 1966869 3rd Qu.:2021-12-30 3rd Qu.: 887825 Max. :2022-10-27 Max. :606210300 NA&#39;s :2183 code_postal id_parcelle lot1_numero lot1_surface_carrez Min. :75001 Length:178526 Min. : 1.0 Min. : 0.50 1st Qu.:75011 Class :character 1st Qu.: 14.0 1st Qu.: 26.00 Median :75014 Mode :character Median : 29.0 Median : 40.33 Mean :75013 Mean : 155.2 Mean : 70.41 3rd Qu.:75017 3rd Qu.: 104.0 3rd Qu.: 64.52 Max. :75020 Max. :100226.0 Max. :9532.00 NA&#39;s :2 NA&#39;s :15112 NA&#39;s :85770 lot2_numero lot2_surface_carrez lot3_numero lot3_surface_carrez Min. : 2.0 Min. : 0.61 Min. : 2.0 Min. : 1.00 1st Qu.: 23.0 1st Qu.: 34.04 1st Qu.: 21.0 1st Qu.: 40.59 Median : 48.0 Median : 51.50 Median : 42.0 Median : 68.18 Mean : 222.7 Mean : 61.06 Mean : 108.6 Mean : 84.22 3rd Qu.: 111.0 3rd Qu.: 75.00 3rd Qu.: 77.0 3rd Qu.:114.67 Max. :21037.0 Max. :7392.00 Max. :11218.0 Max. :685.00 NA&#39;s :88589 NA&#39;s :151775 NA&#39;s :165304 NA&#39;s :176278 lot4_numero lot4_surface_carrez lot5_numero lot5_surface_carrez Min. : 2.00 Min. : 1.30 Min. : 2.00 Min. : 10.52 1st Qu.: 21.00 1st Qu.: 44.91 1st Qu.: 24.00 1st Qu.: 50.75 Median : 44.00 Median : 67.39 Median : 45.00 Median : 74.10 Mean : 99.02 Mean : 82.44 Mean : 90.05 Mean : 95.80 3rd Qu.: 78.00 3rd Qu.:108.13 3rd Qu.: 77.00 3rd Qu.:121.34 Max. :7815.00 Max. :427.60 Max. :4262.00 Max. :345.26 NA&#39;s :174098 NA&#39;s :178049 NA&#39;s :176870 NA&#39;s :178411 nombre_lots type_local surface_reelle_bati Min. : 0.000 Length:178526 Min. : 1.0 1st Qu.: 1.000 Class :character 1st Qu.: 28.0 Median : 2.000 Mode :character Median : 42.0 Mean : 1.537 Mean : 53.1 3rd Qu.: 2.000 3rd Qu.: 67.0 Max. :27.000 Max. :861.0 NA&#39;s :1 nombre_pieces_principales surface_terrain px_m2 Min. : 0.00 Min. : 19.0 Min. : 0 1st Qu.: 1.00 1st Qu.: 231.0 1st Qu.: 9219 Median : 2.00 Median : 395.0 Median : 11040 Mean : 2.41 Mean : 820.7 Mean : 45437 3rd Qu.: 3.00 3rd Qu.: 615.0 3rd Qu.: 13750 Max. :22.00 Max. :6173.0 Max. :46631562 NA&#39;s :1 NA&#39;s :163485 NA&#39;s :2184 annee date_moisan Length:178526 Length:178526 Class :character Class :character Mode :character Mode :character La fonction summary() permet en effet de donner une première information sur les valeurs manquantes des différentes variables. Pour se concentrer sur cette seule information, on peut compter le nombre de valeurs manquantes NA pour chacune des variables avec la fonction colSums() ; pour les avoir en proportion du nombre total d’observations (lignes), on peut utiliser la fonction colMeans() ; sinon ; on peut utiliser la fonction summarise combinée avec across(where()), ) : colSums(is.na(dvf_Paris)) id_mutation date_mutation nature_mutation 0 0 0 valeur_fonciere code_postal id_parcelle 2183 2 0 lot1_numero lot1_surface_carrez lot2_numero 15112 85770 88589 lot2_surface_carrez lot3_numero lot3_surface_carrez 151775 165304 176278 lot4_numero lot4_surface_carrez lot5_numero 174098 178049 176870 lot5_surface_carrez nombre_lots type_local 178411 0 0 surface_reelle_bati nombre_pieces_principales surface_terrain 1 1 163485 px_m2 annee date_moisan 2184 0 0 # Pour les avoir en proportion par rapport au nombre total d&#39;observations # et arrondies à 2 chiffres après la virgule : round(colMeans(is.na(dvf_Paris)*100), 2) id_mutation date_mutation nature_mutation 0.00 0.00 0.00 valeur_fonciere code_postal id_parcelle 1.22 0.00 0.00 lot1_numero lot1_surface_carrez lot2_numero 8.46 48.04 49.62 lot2_surface_carrez lot3_numero lot3_surface_carrez 85.02 92.59 98.74 lot4_numero lot4_surface_carrez lot5_numero 97.52 99.73 99.07 lot5_surface_carrez nombre_lots type_local 99.94 0.00 0.00 surface_reelle_bati nombre_pieces_principales surface_terrain 0.00 0.00 91.57 px_m2 annee date_moisan 1.22 0.00 0.00 # Ou en langage tidyverse sur les seules variables numériques : dvf_Paris %&gt;% summarise(across(where(is.numeric), ~ sum(is.na(.)))) # A tibble: 1 × 17 valeur_fonciere code_postal lot1_numero lot1_surface_carrez lot2_numero &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 2183 2 15112 85770 88589 # ℹ 12 more variables: lot2_surface_carrez &lt;int&gt;, lot3_numero &lt;int&gt;, # lot3_surface_carrez &lt;int&gt;, lot4_numero &lt;int&gt;, lot4_surface_carrez &lt;int&gt;, # lot5_numero &lt;int&gt;, lot5_surface_carrez &lt;int&gt;, nombre_lots &lt;int&gt;, # surface_reelle_bati &lt;int&gt;, nombre_pieces_principales &lt;int&gt;, # surface_terrain &lt;int&gt;, px_m2 &lt;int&gt; Le moins qu’on puisse dire c’est qu’il y a des valeurs manquantes, mais dont le nombre et la proportion (par rapport au nombre total d’observations) varie énormément. Pour en faire une analyse plus poussée, différents packages existent pour détecter et visualiser ces données manquantes. L’un d’entre eux est le package naniar : quelques fonctions permettent d’abord de décrire la base selon ses valeurs manquantes. Cela donne un aperçu global et rapide, mais cela n’est vraiment pas suffisant pour comprendre l’origine et les enjeux (possibles problèmes) de ces valeurs manquantes. library(naniar) Warning: le package &#39;naniar&#39; a été compilé avec la version R 4.3.3 # Ci-dessous : nombre de cellules du tableau ou de n_ij d&#39;une matrice # qui correspondent à des valeurs manquantes : n_miss(dvf_Paris) [1] 1558112 # Pour les avoir en proportion du nombre total de cellules du tableau # et non des seules lignes comme précédemment, # le résultat est déjà en pourcentage, sinon utiliser `prop_miss(RP)`) pct_miss(dvf_Paris) [1] 36.3652 # Ci-dessous : nombre de cellules du tableau ou de n_ij d&#39;une matrice # qui correspondent à des valeurs renseignées : n_complete(dvf_Paris) [1] 2726512 #en proportion pct_complete(dvf_Paris) [1] 63.6348 On peut ensuite visualiser le nombre de valeurs manquantes par variable, avec la fonction gg_miss_var() du même package. On peut également demander dans gg_miss_var() à ce que les valeurs soient en pourcentage, avec l’argument show_pct=TRUE. # 1er type de visualisation des valeurs manquantes dvf_Paris %&gt;% gg_miss_var() On peut aussi réaliser des graphiques montrant le nombre de valeurs manquantes pour l’ensemble des variables numériques de la base, en fonction d’une autre variable (y compris de nature ‘factor’), avec l’argument fct= dans gg_miss_fct(). Cela est intéressant pour voir si certaines valeurs manquantes des variables sont liées à des valeurs observées d’autres variables, qu’elles soient quantitatives ou qualitatives (et dans ce cas, est-ce que les valeurs manquantes se retrouvent davantage dans certaines modalités plus que d’autres ?). Par exemple, ici, selon le type de lots, ou la surface du logement : # on filtre sur les variables numériques car on ne veut pas que la sortie nous affiche # des variables comme le code postal. dvf_Paris %&gt;% select(where(is.numeric), nombre_lots) %&gt;% gg_miss_fct(fct = nombre_lots) dvf_Paris %&gt;% select(where(is.numeric), -(code_postal)) %&gt;% filter(surface_reelle_bati&lt;250) %&gt;% gg_miss_fct(fct = surface_reelle_bati) On voit que les valeurs manquantes sont plus nombreuses pour les variables de numéro et surface carrez des lots 2, 3, 4 et 5 en proportion du nombre de lots, ou encore on observe qu’il y a un petit peu de valeurs manquantes pour les variables de prix au m2 ou de valeur foncière quant le nombre de lots est égal à 0. Elles ne se distribuent donc pas de manière uniforme selon la variable du nombre de lots, mais c’est assez logique ici et on comprend mieux les nombreuses valeurs manquantes pour les variables indiqués “lot2”, “lot3”, etc, car s’il n’y a qu’un ou deux lots c’est normal qu’il n’y ait pas d’informations sur ces variables. En revanche, on note que même avec 0 lot, on peut avoir l’information sur la surface, le prix/la valeur foncière, puisque ce n’est pas toujours manquant. Plus généralement, la fonction gg_miss_upset() de ce même package naniar permet de visualiser des dépendances entre les valeurs manquantes des variables : dvf_Paris %&gt;% select(where(is.numeric)) %&gt;% gg_miss_upset() Cela nous montre qu’il y a beaucoup d’observations où on a des valeurs manquantes pour 5 variables indiquées, qu’ensuite le cas le plus probable c’est des valeurs manquantes pour 4 de ces 5 variables, etc. Enfin, il est possible d’appliquer la fonction geom_miss_point() à une fonction ggplot, dans ce cas les valeurs manquantes de la ou des variables sont remplacées par des valeurs 10% plus basses que la valeur minimum observée des variables, et cela afin de les visualiser. Il existe bien sûr bien d’autres packages, comme funModeling, Amelia et sa fonction missmap(), ou encore visdat et sa fonction vis_miss(). Enfin, d’autres packages comme VIM ou MICE permettent, non seulement de visualiser ces valeurs manquantes, mais également de leur appliquer des techniques pour les “gérer”, c’est ce que l’on va voir maintenant en résumé. 3.2.2 Gérer les valeurs manquantes Il est bien de connaître le nombre et la proportion de valeurs manquantes dans nos données, comment ces dernières se répartissent entre elles, etc., mais il faut aussi comprendre quel impact elles peuvent avoir sur des analyses statistiques, de régressions ou autres algorithmes. Dans une base de données tirée d’une enquête, les valeurs manquantes peuvent provenir d’une non-réponse de la part de l’enquêté (que ce soit un individu ou une entreprise), cette non-réponse pouvant être “totale” (on a aucune donnée pour cet enquêté alors qu’il fait partie de l’échantillon) ou “partielle” (on a une partie des réponses mais pas à toutes les questions et donc des variables parfois avec des valeurs manquantes) ; ou bien encore elles peuvent être dues à une mauvaise saisie de l’information par l’enquêteur. La pondération, si elle est présente dans une enquête, peut permettre de corriger cette non-réponse totale, voire partielle. Les conséquences des valeurs manquantes dans une base de données dépendent de plusieurs choses : on doit d’abord se demander si l’information perdue aurait été pertinente et/ou aurait apporté un élément particulier/supplémentaire. Ensuite, la perte éventuelle d’information est-elle importante, en nombre/en proportion. Et enfin (et surtout), peut-elle créer un biais lors de l’estimation et précision du phénomène que l’on souhaite observer, décrire, analyser, etc. Selon l’importance de ces conséquences, il faut traiter ces valeurs manquantes, c’est-à-dire utiliser une procédure la plus adaptée possible selon le potentiel biais repéré. Traditionnellement dans la littérature, on distingue 3 types de valeurs manquantes : valeur manquante entièrement due au hasard (‘MCAR’ pour Missing completely at random) : il n’y a pas de lien entre la valeur manquante pour une variable donnée et les autres variables, dit autrement la probabilité pour une variable qu’elle ait une valeur manquante est constante dans les données, elle ne diffère pas selon d’autres caractéristiques des individus ; valeur manquante due au hasard (‘MAR’ pour Missing at random) : il y a un lien entre la valeur manquante pour une variable donnée et les valeurs observées d’autres variables, c’est-à-dire que la probabilité pour une variable qu’elle ait une valeur manquante dépend d’autres variables (de leurs valeurs observées), elle ne sera donc pas la même selon les individus, c’est ce qu’on essayait de regarder lorsqu’on a utilisé plus haut la fonction gg_miss_fct(fct=) ; valeur ne manquant pas au hasard (‘NMAR’ pour Non missing at random) : il y a un lien entre la valeur manquante pour une variable et les valeurs manquantes/non observées d’autres variables. Ce sont celles qui risquent d’entraîner des biais importants si on ne les traite pas, c’est ce qu’on essayait de regarder plus haut également avec la fonction gg_miss_upset() cette fois. Comment alors les gérer ? En pratique, il est d’usage lorsque la proportion de valeurs manquantes ne dépasse pas 5% des données de ne rien faire de particulier ou simplement de les supprimer (vous pouvez pour la savoir utiliser les premières fonctions du package naniar présentées précédemment). Sinon, on essaye d’appliquer plusieurs méthodes, simples ou plus complexes. Dans le cas de valeurs manquantes entièrement dues au hasard (MCAR) et/ou d’une faible proportion des valeurs manquantes dans le total de la table de données, on peut décider de supprimer toutes les lignes qui contiennent au moins une valeur manquante, afin d’avoir une table de données complètes, on peut utiliser la fonction na.omit() ou complete.cases() ; attention à ne pas remplacer votre table de données initiale en réalisant cette procédure. On ne va pas s’essayer à le faire ici car on a vu au tout début de cette section que pour certaines variables cela concernait pratiquement toutes les observations (ici les ventes observées), la conséquence c’est qu’ici on va supprimer toutes les lignes car une ligne a forcément une valeur manquante dans une des variables. Le code serait celui-ci : dvf_Paris_sansNA &lt;- na.omit(dvf_Paris) # OU : # dvf_Paris_sansNA &lt;- dvf_Paris[complete.cases(dvf_Paris), ] Des techniques d’imputation simple peuvent également être utilisées. On peut par exemple remplacer les valeurs manquantes d’une variable quantitative par sa moyenne ou sa médiane, pour cela on peut utiliser la fonction replace_na() du package tidyr, ou impute() du package Hmisc, ou encore na.aggregate() du package zoo On donne ainsi une valeur “artificielle” pour remplacer la valeur manquante. Dans le cas de variables qualitatives, on peut, de même, imputer la modalité dominante (avec la fonction mode() du package Hmisc ; ou avec l’argument mode= du package zoo). Par exemple, voici les codes pour remplacer les valeurs manquantes de la variable ‘pxm2’ par sa médiane (la base n’étant pas propre il vaut mieux utiliser la médiane que la moyenne) : dvf_Paris %&gt;% mutate(px_m2_bis = replace_na(px_m2, median(px_m2, na.rm=TRUE))) %&gt;% select(px_m2, px_m2_bis) %&gt;% filter(is.na(px_m2)) library(Hmisc) dvf_Paris$px_m2_bis &lt;- with(dvf_Paris, impute(px_m2, median)) library(zoo) dvf_Paris$px_m2_bis &lt;- na.aggregate(dvf_Paris$ px_m2, FUN = median) On peut néanmoins réaliser ce type d’imputation simple de manière un petit peu plus subtile. Par exemple, si la moyenne de la variable diffère sensiblement selon une autre variable (catégorielle), dans ce cas, on va plutôt remplacer les valeurs manquantes de la variable selon la moyenne associée à chaque modalité de cette autre variable en ajoutant un group_by() avant la fonction mutate() si on utilise la fonction replace_na() comme dans l’exemple précédent. Si on ne veut pas supprimer ces lignes d’observations et perdre ainsi d’autres informations (celles des variables pour lesquelles la valeur était renseignée pour cette même observation), on peut simplement créer une variable indicatrice de valeur manquante, remplacer les NA par ‘999’ comme dans notre base de données actuelle pour des variables quantitatives, ou par une modalité ‘Manquant’ ou ‘Missing’ pour des variables qualitatives. Plusieurs autres méthodes existent également dans le cas de valeurs manquantes dues au hasard (MAR), en voici la liste pour information et sans prétention d’exhaustivité : - analyse pondérée pour des valeurs MAR qui consiste à calculer la probabilité qu’une observation soit complète et ensuite à affecter à chacune des observations complètes, un poids inversement proportionnel à cette probabilité ; - imputation de la dernière observation pour des données temporelles ; - imputation “hot-deck” qui consiste à remplacer la valeur manquante par une valeur observée chez un autre individu ayant les mêmes caractéristiques, ou “cold-deck” (même démarche que précédement, sauf que la valeur imputée vient d’une autre source) ; - imputation par le “plus proche voisin” en utilisant une fonction de distance basée sur plusieurs autres variables/caractéristiques de l’individu ; - imputation par un modèle de régression où l’on va remplacer la valeur manquante par une valeur prédite obtenue par régression sur données complètes de la variable comportant des valeurs manquantes. Il y a aussi des techniques plus complextes d’imputation multiple qui consiste à créer plusieurs valeurs possibles pour une valeur manquante d’une variable, cela peut être adaptée là aussi lorsque les valeurs manquantes sont dues au hasard (MAR). Vous trouverez de multiples ressources sur internet dans des ouvrages libres d’accès, ou vous pouvez aller voir un des chapitres de l’ouvrage principal support du cours (Husson, 2018), avec des exemples d’utilisation. 3.2.3 Détecter et “visualiser” les valeurs aberrantes On va continuer avec cette base de données en se concentrant sur les variables de valeur foncière, de surface, de nombre de pièces, etde prix au m2, en s’intéressant maintenant aux valeurs aberrantes. On peut d’abord étudier la distribution de ces variables : la fonction get_summary_stats() du package rstatix permet de donner les statistiques de distribution des variables, on propose d’afficher les principales ici : library(rstatix) dvf_Paris %&gt;% get_summary_stats(valeur_fonciere, nombre_pieces_principales, surface_reelle_bati, px_m2, nombre_lots, show=c(&quot;n&quot;,&quot;mean&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;,&quot;q1&quot;, &quot;q3&quot;)) %&gt;% gt() #ygcoldigfd table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #ygcoldigfd thead, #ygcoldigfd tbody, #ygcoldigfd tfoot, #ygcoldigfd tr, #ygcoldigfd td, #ygcoldigfd th { border-style: none; } #ygcoldigfd p { margin: 0; padding: 0; } #ygcoldigfd .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #ygcoldigfd .gt_caption { padding-top: 4px; padding-bottom: 4px; } #ygcoldigfd .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #ygcoldigfd .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #ygcoldigfd .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ygcoldigfd .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ygcoldigfd .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ygcoldigfd .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #ygcoldigfd .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #ygcoldigfd .gt_column_spanner_outer:first-child { padding-left: 0; } #ygcoldigfd .gt_column_spanner_outer:last-child { padding-right: 0; } #ygcoldigfd .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #ygcoldigfd .gt_spanner_row { border-bottom-style: hidden; } #ygcoldigfd .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #ygcoldigfd .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #ygcoldigfd .gt_from_md > :first-child { margin-top: 0; } #ygcoldigfd .gt_from_md > :last-child { margin-bottom: 0; } #ygcoldigfd .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #ygcoldigfd .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #ygcoldigfd .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #ygcoldigfd .gt_row_group_first td { border-top-width: 2px; } #ygcoldigfd .gt_row_group_first th { border-top-width: 2px; } #ygcoldigfd .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ygcoldigfd .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #ygcoldigfd .gt_first_summary_row.thick { border-top-width: 2px; } #ygcoldigfd .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ygcoldigfd .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ygcoldigfd .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #ygcoldigfd .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #ygcoldigfd .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #ygcoldigfd .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ygcoldigfd .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ygcoldigfd .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #ygcoldigfd .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ygcoldigfd .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #ygcoldigfd .gt_left { text-align: left; } #ygcoldigfd .gt_center { text-align: center; } #ygcoldigfd .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #ygcoldigfd .gt_font_normal { font-weight: normal; } #ygcoldigfd .gt_font_bold { font-weight: bold; } #ygcoldigfd .gt_font_italic { font-style: italic; } #ygcoldigfd .gt_super { font-size: 65%; } #ygcoldigfd .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #ygcoldigfd .gt_asterisk { font-size: 100%; vertical-align: 0; } #ygcoldigfd .gt_indent_1 { text-indent: 5px; } #ygcoldigfd .gt_indent_2 { text-indent: 10px; } #ygcoldigfd .gt_indent_3 { text-indent: 15px; } #ygcoldigfd .gt_indent_4 { text-indent: 20px; } #ygcoldigfd .gt_indent_5 { text-indent: 25px; } variable n mean median min max q1 q3 valeur_fonciere 176343 1966869.429 480000.00 0.150 606210300 285000.00 887825 nombre_pieces_principales 178525 2.410 2.00 0.000 22 1.00 3 surface_reelle_bati 178525 53.100 42.00 1.000 861 28.00 67 px_m2 176342 45436.542 11040.33 0.004 46631562 9218.75 13750 nombre_lots 178526 1.537 2.00 0.000 27 1.00 2 Cela nous permet de comprendre qu’il y a probablement encore quelques filtres à effectuer pour avoir une base propre et cohérente, non seulement sur les valeurs aberrantes - on va y venir - mais aussi sur les valeurs minimum. Peut-on ainsi vendre un appartement avec 0 pièce principale ? Ou d’une surface d’1 m2 ? Ou pour 0€ ? On va donc filtrer la base sur ces éléments. De plus, comme on a vu qu’il y avait beaucoup de valeurs manquantes sur les variables reliées aux numéros de lot supérieur à 3, on va retenir dans la base les seules ventes avec des lots compris entre 1 et 2 (en gros, par exemple, un appartement - lot 1 - ou un appartement et une cave - lot 2). # Filtre pour réduire la base et la rendre plus propre, et sélection en supprimant les # variables qui ne nous intéressents plus dvf_Paris &lt;- dvf_Paris %&gt;% filter(nombre_lots %in% c(1,2) &amp; nombre_pieces_principales&gt;0 &amp; surface_reelle_bati&gt;=9 &amp; valeur_fonciere&gt;0) %&gt;% select(-c(lot5_surface_carrez, lot5_numero, lot4_surface_carrez, lot4_numero, lot3_surface_carrez, lot3_numero)) On peut relancer nos statistiques précédentes, pour vérifier que c’est plus cohérent et aussi pour étudier maintenant les maximum de certaines variables, c’est en effet une première manière de voir de potentielles valeurs aberrantes. dvf_Paris %&gt;% get_summary_stats(valeur_fonciere, nombre_pieces_principales, surface_reelle_bati, px_m2, show=c(&quot;n&quot;,&quot;mean&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;,&quot;q1&quot;, &quot;q3&quot;,&quot;iqr&quot;)) %&gt;% gt() %&gt;% fmt_number(columns = 3:8, sep_mark = &quot; &quot;, decimals = 1) #mfvprnenyq table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #mfvprnenyq thead, #mfvprnenyq tbody, #mfvprnenyq tfoot, #mfvprnenyq tr, #mfvprnenyq td, #mfvprnenyq th { border-style: none; } #mfvprnenyq p { margin: 0; padding: 0; } #mfvprnenyq .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #mfvprnenyq .gt_caption { padding-top: 4px; padding-bottom: 4px; } #mfvprnenyq .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #mfvprnenyq .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #mfvprnenyq .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mfvprnenyq .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mfvprnenyq .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mfvprnenyq .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #mfvprnenyq .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #mfvprnenyq .gt_column_spanner_outer:first-child { padding-left: 0; } #mfvprnenyq .gt_column_spanner_outer:last-child { padding-right: 0; } #mfvprnenyq .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #mfvprnenyq .gt_spanner_row { border-bottom-style: hidden; } #mfvprnenyq .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #mfvprnenyq .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #mfvprnenyq .gt_from_md > :first-child { margin-top: 0; } #mfvprnenyq .gt_from_md > :last-child { margin-bottom: 0; } #mfvprnenyq .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #mfvprnenyq .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #mfvprnenyq .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #mfvprnenyq .gt_row_group_first td { border-top-width: 2px; } #mfvprnenyq .gt_row_group_first th { border-top-width: 2px; } #mfvprnenyq .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #mfvprnenyq .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #mfvprnenyq .gt_first_summary_row.thick { border-top-width: 2px; } #mfvprnenyq .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mfvprnenyq .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #mfvprnenyq .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #mfvprnenyq .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #mfvprnenyq .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #mfvprnenyq .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mfvprnenyq .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mfvprnenyq .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #mfvprnenyq .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mfvprnenyq .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #mfvprnenyq .gt_left { text-align: left; } #mfvprnenyq .gt_center { text-align: center; } #mfvprnenyq .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #mfvprnenyq .gt_font_normal { font-weight: normal; } #mfvprnenyq .gt_font_bold { font-weight: bold; } #mfvprnenyq .gt_font_italic { font-style: italic; } #mfvprnenyq .gt_super { font-size: 65%; } #mfvprnenyq .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #mfvprnenyq .gt_asterisk { font-size: 100%; vertical-align: 0; } #mfvprnenyq .gt_indent_1 { text-indent: 5px; } #mfvprnenyq .gt_indent_2 { text-indent: 10px; } #mfvprnenyq .gt_indent_3 { text-indent: 15px; } #mfvprnenyq .gt_indent_4 { text-indent: 20px; } #mfvprnenyq .gt_indent_5 { text-indent: 25px; } variable n mean median min max q1 q3 iqr valeur_fonciere 148468 828 062.7 436 000.0 0.1 318 200 000.0 270 000.0 730 000.0 460000.000 nombre_pieces_principales 148468 2.4 2.0 1.0 22.0 1.0 3.0 2.000 surface_reelle_bati 148468 51.4 42.0 9.0 861.0 27.0 65.0 38.000 px_m2 148468 17 120.7 10 740.7 0.0 10 606 666.7 9 038.5 12 758.9 3720.472 On peut également faire quelques graphs sur cette pour mieux visualiser ces valeurs aberrantes, un histogramme, ou une “boîte à moustache” (seule ou en relation avec une autre variable) : dvf_Paris %&gt;% ggplot() + aes(x=px_m2) + geom_histogram(bins=50) dvf_Paris %&gt;% ggplot() + aes(x = annee, y = px_m2) + geom_boxplot() + coord_flip() On voit bien que ce soit avec l’histogramme ou la boîte à moustâche des points aberrants qui “écrasent” les représentations graphiques, de telle sorte qu’on ne voit même pas la distribution, en particulier dans le Boxplot la “boîte” en elle-même. Pour rappel, dans un boxplot, par défaut un point est affiché comme aberrant s’il est en dehors de l’intervalle suivant : \\(I=[Q_{1}−1.5×IQR ; Q_{3}+1.5×IQR]\\), IQR étant l’intervalle interquartile donc la différence entre Q1 et Q3. Mais s’agit-il de “vraies” valeurs aberrantes ? Combien d’observations concernent-elles ? La fonction boxplot.stats() permet de récupérer les valeurs des observations indiquées comme aberrantes, comme cela on peut créer ensuite une variable indiquant si oui ou non l’observation a une valeur “aberrante”. Faisons-cela pour la variable de valeur foncière. # On récupère les valeurs de la partie &#39;out&#39; des sorties de la fonction # &#39;boxplot.stats&#39;, qui correspondent aux valeurs de tout point de données # qui se situe au-delà des extrêmes de la boxplot val_outliers &lt;- boxplot.stats(dvf_Paris$px_m2)$out # On crée une variable dans notre table d&#39;&quot;identification&quot; de ces outliers # avec comme modalité &quot;vraie&quot; si l&#39;observation a une valeur &quot;outliers&quot;, # sinon &quot;Faux&quot; dvf_Paris &lt;- dvf_Paris %&gt;% mutate(px_m2_outliers = case_when(px_m2 %in% c(val_outliers) ~ &quot;Vrai&quot;, TRUE ~ &quot;Faux&quot;)) # Puis on regarde la répartition avec la fonction `tabyl()` du package `janitor()` library(janitor) dvf_Paris %&gt;% tabyl(px_m2_outliers) %&gt;% adorn_pct_formatting() %&gt;% adorn_totals(&quot;row&quot;) %&gt;% gt() #utqmbuelxc table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #utqmbuelxc thead, #utqmbuelxc tbody, #utqmbuelxc tfoot, #utqmbuelxc tr, #utqmbuelxc td, #utqmbuelxc th { border-style: none; } #utqmbuelxc p { margin: 0; padding: 0; } #utqmbuelxc .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #utqmbuelxc .gt_caption { padding-top: 4px; padding-bottom: 4px; } #utqmbuelxc .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #utqmbuelxc .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #utqmbuelxc .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #utqmbuelxc .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #utqmbuelxc .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #utqmbuelxc .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #utqmbuelxc .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #utqmbuelxc .gt_column_spanner_outer:first-child { padding-left: 0; } #utqmbuelxc .gt_column_spanner_outer:last-child { padding-right: 0; } #utqmbuelxc .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #utqmbuelxc .gt_spanner_row { border-bottom-style: hidden; } #utqmbuelxc .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #utqmbuelxc .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #utqmbuelxc .gt_from_md > :first-child { margin-top: 0; } #utqmbuelxc .gt_from_md > :last-child { margin-bottom: 0; } #utqmbuelxc .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #utqmbuelxc .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #utqmbuelxc .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #utqmbuelxc .gt_row_group_first td { border-top-width: 2px; } #utqmbuelxc .gt_row_group_first th { border-top-width: 2px; } #utqmbuelxc .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #utqmbuelxc .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #utqmbuelxc .gt_first_summary_row.thick { border-top-width: 2px; } #utqmbuelxc .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #utqmbuelxc .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #utqmbuelxc .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #utqmbuelxc .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #utqmbuelxc .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #utqmbuelxc .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #utqmbuelxc .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #utqmbuelxc .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #utqmbuelxc .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #utqmbuelxc .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #utqmbuelxc .gt_left { text-align: left; } #utqmbuelxc .gt_center { text-align: center; } #utqmbuelxc .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #utqmbuelxc .gt_font_normal { font-weight: normal; } #utqmbuelxc .gt_font_bold { font-weight: bold; } #utqmbuelxc .gt_font_italic { font-style: italic; } #utqmbuelxc .gt_super { font-size: 65%; } #utqmbuelxc .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #utqmbuelxc .gt_asterisk { font-size: 100%; vertical-align: 0; } #utqmbuelxc .gt_indent_1 { text-indent: 5px; } #utqmbuelxc .gt_indent_2 { text-indent: 10px; } #utqmbuelxc .gt_indent_3 { text-indent: 15px; } #utqmbuelxc .gt_indent_4 { text-indent: 20px; } #utqmbuelxc .gt_indent_5 { text-indent: 25px; } px_m2_outliers n percent Faux 128824 86.8% Vrai 19644 13.2% Total 148468 - On y lit que pour cette variable, il y aurait près de 13,2% de valeurs aberrantes telles qu’indiquées par le boxplot, ce qui correspondant à 19 644 observations, c’est beaucoup ! On peut regarder plus précisément à quelles observations elles correspondent, en sélectionnant avec la variable créée et en triant par ordre croissant ou décroissant. dvf_Paris %&gt;% filter(px_m2_outliers==&#39;Vrai&#39;) %&gt;% select(px_m2, nombre_pieces_principales, surface_reelle_bati, valeur_fonciere) %&gt;% arrange(px_m2) %&gt;% head(5) %&gt;% gt() #mwdnbzzfvb table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #mwdnbzzfvb thead, #mwdnbzzfvb tbody, #mwdnbzzfvb tfoot, #mwdnbzzfvb tr, #mwdnbzzfvb td, #mwdnbzzfvb th { border-style: none; } #mwdnbzzfvb p { margin: 0; padding: 0; } #mwdnbzzfvb .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #mwdnbzzfvb .gt_caption { padding-top: 4px; padding-bottom: 4px; } #mwdnbzzfvb .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #mwdnbzzfvb .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #mwdnbzzfvb .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mwdnbzzfvb .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mwdnbzzfvb .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mwdnbzzfvb .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #mwdnbzzfvb .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #mwdnbzzfvb .gt_column_spanner_outer:first-child { padding-left: 0; } #mwdnbzzfvb .gt_column_spanner_outer:last-child { padding-right: 0; } #mwdnbzzfvb .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #mwdnbzzfvb .gt_spanner_row { border-bottom-style: hidden; } #mwdnbzzfvb .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #mwdnbzzfvb .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #mwdnbzzfvb .gt_from_md > :first-child { margin-top: 0; } #mwdnbzzfvb .gt_from_md > :last-child { margin-bottom: 0; } #mwdnbzzfvb .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #mwdnbzzfvb .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #mwdnbzzfvb .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #mwdnbzzfvb .gt_row_group_first td { border-top-width: 2px; } #mwdnbzzfvb .gt_row_group_first th { border-top-width: 2px; } #mwdnbzzfvb .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #mwdnbzzfvb .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #mwdnbzzfvb .gt_first_summary_row.thick { border-top-width: 2px; } #mwdnbzzfvb .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mwdnbzzfvb .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #mwdnbzzfvb .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #mwdnbzzfvb .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #mwdnbzzfvb .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #mwdnbzzfvb .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mwdnbzzfvb .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mwdnbzzfvb .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #mwdnbzzfvb .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mwdnbzzfvb .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #mwdnbzzfvb .gt_left { text-align: left; } #mwdnbzzfvb .gt_center { text-align: center; } #mwdnbzzfvb .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #mwdnbzzfvb .gt_font_normal { font-weight: normal; } #mwdnbzzfvb .gt_font_bold { font-weight: bold; } #mwdnbzzfvb .gt_font_italic { font-style: italic; } #mwdnbzzfvb .gt_super { font-size: 65%; } #mwdnbzzfvb .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #mwdnbzzfvb .gt_asterisk { font-size: 100%; vertical-align: 0; } #mwdnbzzfvb .gt_indent_1 { text-indent: 5px; } #mwdnbzzfvb .gt_indent_2 { text-indent: 10px; } #mwdnbzzfvb .gt_indent_3 { text-indent: 15px; } #mwdnbzzfvb .gt_indent_4 { text-indent: 20px; } #mwdnbzzfvb .gt_indent_5 { text-indent: 25px; } px_m2 nombre_pieces_principales surface_reelle_bati valeur_fonciere 0.003750000 2 40 0.15 0.003906250 7 256 1.00 0.005128205 5 195 1.00 0.005128205 5 195 1.00 0.005882353 5 170 1.00 dvf_Paris %&gt;% filter(px_m2_outliers==&#39;Vrai&#39;) %&gt;% select(px_m2, nombre_pieces_principales, surface_reelle_bati, valeur_fonciere) %&gt;% arrange(desc(px_m2)) %&gt;% head(5) %&gt;% gt() #enexrcsprg table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #enexrcsprg thead, #enexrcsprg tbody, #enexrcsprg tfoot, #enexrcsprg tr, #enexrcsprg td, #enexrcsprg th { border-style: none; } #enexrcsprg p { margin: 0; padding: 0; } #enexrcsprg .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #enexrcsprg .gt_caption { padding-top: 4px; padding-bottom: 4px; } #enexrcsprg .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #enexrcsprg .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #enexrcsprg .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #enexrcsprg .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #enexrcsprg .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #enexrcsprg .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #enexrcsprg .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #enexrcsprg .gt_column_spanner_outer:first-child { padding-left: 0; } #enexrcsprg .gt_column_spanner_outer:last-child { padding-right: 0; } #enexrcsprg .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #enexrcsprg .gt_spanner_row { border-bottom-style: hidden; } #enexrcsprg .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #enexrcsprg .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #enexrcsprg .gt_from_md > :first-child { margin-top: 0; } #enexrcsprg .gt_from_md > :last-child { margin-bottom: 0; } #enexrcsprg .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #enexrcsprg .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #enexrcsprg .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #enexrcsprg .gt_row_group_first td { border-top-width: 2px; } #enexrcsprg .gt_row_group_first th { border-top-width: 2px; } #enexrcsprg .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #enexrcsprg .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #enexrcsprg .gt_first_summary_row.thick { border-top-width: 2px; } #enexrcsprg .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #enexrcsprg .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #enexrcsprg .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #enexrcsprg .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #enexrcsprg .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #enexrcsprg .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #enexrcsprg .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #enexrcsprg .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #enexrcsprg .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #enexrcsprg .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #enexrcsprg .gt_left { text-align: left; } #enexrcsprg .gt_center { text-align: center; } #enexrcsprg .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #enexrcsprg .gt_font_normal { font-weight: normal; } #enexrcsprg .gt_font_bold { font-weight: bold; } #enexrcsprg .gt_font_italic { font-style: italic; } #enexrcsprg .gt_super { font-size: 65%; } #enexrcsprg .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #enexrcsprg .gt_asterisk { font-size: 100%; vertical-align: 0; } #enexrcsprg .gt_indent_1 { text-indent: 5px; } #enexrcsprg .gt_indent_2 { text-indent: 10px; } #enexrcsprg .gt_indent_3 { text-indent: 15px; } #enexrcsprg .gt_indent_4 { text-indent: 20px; } #enexrcsprg .gt_indent_5 { text-indent: 25px; } px_m2 nombre_pieces_principales surface_reelle_bati valeur_fonciere 10606667 1 30 318200000 10606667 1 30 318200000 5582456 2 57 318200000 5582456 2 57 318200000 2560494 4 81 207400000 On voit donc qu’il y a des valeurs considérées comme aberrantes en bas de la distribution (valeurs trop faible) et en haut de la distribution ; ici sur les 5 premières valeurs, on a bien l’impression que ce sont des valeurs aberrantes. Pour être plus précis, on peut calculer les valeurs seuils bas et haut puisqu’on connaît la formule. Le seuil bas sera : 3457.7539401 et le seuil haut : 1.8339641^{4}. Ces seuils peuvent donc être vraisemblables en réalité. Il est donc important de comprendre ces valeurs aberrantes, cela peut parfois correspondre à des observations intéressantes à conserver, il ne s’agit pas juste de les identifier pour les exclure directement ensuite des analyses. Il existe d’autres méthodes (méthode basée sur les percentiles ; méthode de Hampel), et d’autres tests : par exemple, le package outliers vous permet de tester si une valeur (max ou min) est bien une valeur aberrante avec la fonction grubbs.test() (attention bis : à utiliser avec grande précaution et beaucoup de parcimonie), ou avec le package EnvStats et la fonction rosnerTest() pour détecter plusieurs “outliers” à la fois. Pour gérer ces variables aberrantes, on peut les supprimer bien sûr si l’on est sûr que la valeur de la variable n’est pas “normale”, par exemple si on a une variable de salaire avec des modalités inférieures à 0, oui dans ce cas ce sont des mauvais outliers (et d’ailleurs peut-être même pas identifiés comme tel statistiquement) et on peut les supprimer ; de même pour des variables de résultats économiques, on va souvent élaguer la distribution en retirant les 1% (par exemple) du bas et du haut de la distribution pour supprimer des potentiels outliers. On peut tenter cette méthode ici en filtrant les données avant de calculer la distribution de la variable. Sinon, on les isole en créant une variable dichotomique “0/1” ou “Faux/Vrai” ; ou on crée une variable qualitative avec plusieurs catégories (cf. sous-section suivante). Dans les graphiques, en particulier les boîtes à moustache, on peut les supprimer visuellement avec l’option outlier.shape = NA et mettre ensuite une échelle plus réduite (avec ylim=c( , )) pour que le graphique soit plus lisible, mais il faut alors bien préciser dans la légende que certaines valeurs ne sont pas visibles sur le graphique car retirées ; attention à ne pas les supprimer de la base sur laquelle est réalisée la boxplot car sinon cela va modifier les indicateurs (en particulier de moyenne mais pas seulement). Dans un histogramme, on peut de même jouer sur l’échelle. dvf_Paris %&gt;% ggplot() + aes(y = px_m2) + geom_boxplot(outlier.shape = NA) + coord_flip(ylim = c(quantile(dvf_Paris$px_m2, 0.01),quantile(dvf_Paris$px_m2, 0.99))) + labs(title = &quot;Distribution des valeurs foncières en euros&quot;, y=&quot;&quot;, x=&quot;&quot;, caption=&quot;Rq : les valeurs en-dessous du 1% de la distribution et celles au-dessus du 99% de la distribution ne sont pas \\naffichées sur le graphique.&quot;) + theme(plot.caption = element_text(hjust=0)) dvf_Paris %&gt;% ggplot() + aes(px_m2) + geom_histogram(bins=10000) + coord_cartesian(xlim=c(quantile(dvf_Paris$px_m2, 0.01), quantile(dvf_Paris$px_m2, 0.99))) + labs(title = &quot;Distribution des valeurs foncières en euros&quot;, y=&quot;&quot;, x=&quot;Prix au m2&quot;, caption=&quot;Rq : les valeurs en-dessous du 1% de la distribution et celles au-dessus du 99% de la distribution ne sont pas \\naffichées sur le graphique.&quot;) + theme(plot.caption = element_text(hjust=0)) C’est un peu mieux mais on voit que la boxplot est toujours écrasée… et sur l’histogramme on voit qu’il y a probablement encore un problème pour les valeurs faibles du prix au m2 qu’il faudrait “nettoyer”. On peut refaire le graphique en élaguant davantage en bas de la distribution par exemple : dvf_Paris %&gt;% ggplot() + aes(px_m2) + geom_histogram(bins=20000) + coord_cartesian(xlim=c(quantile(dvf_Paris$px_m2, 0.05), quantile(dvf_Paris$px_m2, 0.95))) + labs(title = &quot;Distribution des valeurs foncières en euros&quot;, y=&quot;&quot;, x=&quot;Prix au m2&quot;, caption=&quot;Rq : les valeurs en-dessous du 5% de la distribution et celles au-dessus du 95% de la distribution ne sont pas \\naffichées sur le graphique.&quot;) + theme(plot.caption = element_text(hjust=0)) 3.2.4 Découper en classes une variable quantitative On peut enfin découper en classes une variable quantitative et en faire donc une variable qualitative. On utilise pour cela la fonction cut() du langage de base de R. On peut par exemple découper la variable selon les principaux indicateurs de la distribution. #dvf_Paris %&gt;% get_summary_stats(px_m2) dvf_Paris$px_m2_cat &lt;- cut(dvf_Paris$px_m2, breaks = c(0, quantile(dvf_Paris$px_m2,0.25), mean(dvf_Paris$px_m2), max(dvf_Paris$px_m2)), labels=c(&quot;entre 0 et le Q1(9038€)&quot;, &quot;Entre le Q1 et la moyenne (17121€)&quot;, &quot;Entre la moyenne et le maximum&quot;)) dvf_Paris %&gt;% tabyl(px_m2_cat) %&gt;% adorn_pct_formatting() %&gt;% adorn_totals(&quot;row&quot;) %&gt;% gt() #ldgfrldtdg table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #ldgfrldtdg thead, #ldgfrldtdg tbody, #ldgfrldtdg tfoot, #ldgfrldtdg tr, #ldgfrldtdg td, #ldgfrldtdg th { border-style: none; } #ldgfrldtdg p { margin: 0; padding: 0; } #ldgfrldtdg .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #ldgfrldtdg .gt_caption { padding-top: 4px; padding-bottom: 4px; } #ldgfrldtdg .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #ldgfrldtdg .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #ldgfrldtdg .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ldgfrldtdg .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ldgfrldtdg .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ldgfrldtdg .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #ldgfrldtdg .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #ldgfrldtdg .gt_column_spanner_outer:first-child { padding-left: 0; } #ldgfrldtdg .gt_column_spanner_outer:last-child { padding-right: 0; } #ldgfrldtdg .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #ldgfrldtdg .gt_spanner_row { border-bottom-style: hidden; } #ldgfrldtdg .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #ldgfrldtdg .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #ldgfrldtdg .gt_from_md > :first-child { margin-top: 0; } #ldgfrldtdg .gt_from_md > :last-child { margin-bottom: 0; } #ldgfrldtdg .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #ldgfrldtdg .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #ldgfrldtdg .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #ldgfrldtdg .gt_row_group_first td { border-top-width: 2px; } #ldgfrldtdg .gt_row_group_first th { border-top-width: 2px; } #ldgfrldtdg .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ldgfrldtdg .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #ldgfrldtdg .gt_first_summary_row.thick { border-top-width: 2px; } #ldgfrldtdg .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ldgfrldtdg .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ldgfrldtdg .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #ldgfrldtdg .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #ldgfrldtdg .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #ldgfrldtdg .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ldgfrldtdg .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ldgfrldtdg .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #ldgfrldtdg .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ldgfrldtdg .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #ldgfrldtdg .gt_left { text-align: left; } #ldgfrldtdg .gt_center { text-align: center; } #ldgfrldtdg .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #ldgfrldtdg .gt_font_normal { font-weight: normal; } #ldgfrldtdg .gt_font_bold { font-weight: bold; } #ldgfrldtdg .gt_font_italic { font-style: italic; } #ldgfrldtdg .gt_super { font-size: 65%; } #ldgfrldtdg .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #ldgfrldtdg .gt_asterisk { font-size: 100%; vertical-align: 0; } #ldgfrldtdg .gt_indent_1 { text-indent: 5px; } #ldgfrldtdg .gt_indent_2 { text-indent: 10px; } #ldgfrldtdg .gt_indent_3 { text-indent: 15px; } #ldgfrldtdg .gt_indent_4 { text-indent: 20px; } #ldgfrldtdg .gt_indent_5 { text-indent: 25px; } px_m2_cat n percent entre 0 et le Q1(9038€) 37143 25.0% Entre le Q1 et la moyenne (17121€) 97086 65.4% Entre la moyenne et le maximum 14239 9.6% Total 148468 - On a une classe majoritaire (du Q1 à la moyenne), mais cela nous permet de distinguer 2 classes pour lesquelles le montant du prix au m2 est soit plutôt faible, soit plutôt élevé. À noter que si la variable quantitative en question a des valeurs manquantes, il faudra utiliser la fonction fancycut() ou wafflecut() du package fancycut, l’inconvénient est que cela nous oblige à indiquer les valeurs des différents indicateurs de la distribution. "],["04-Récapitulatif.html", "Section 4 Récapitulatig séance 1 - Data Wrangling 4.1 Ce qu’on a appris 4.2 Enregistrement des tables", " Section 4 Récapitulatig séance 1 - Data Wrangling 4.1 Ce qu’on a appris Cette séance sur la préparation et nettoyage d’une base de données - phase appelée aussi Data Wrangling - nous a permis d’apprendre à : charger des bases de données, y compris dans le cas d’un fichier lourd avec la fonction fread() du package data.table ; repérer les informations intéressantes contenues dans cette base, notamment en allant voir le fichier “annexe”, celui des métadonneés (ou dictionnaire des codes) ; mais ce type de fichier n’est pas toujours disponible, si vous avez des données d’une entreprise, peut-être que l’information décrivant cette base est plus informelle, ou même si vous “aspirez” des données via le web vous n’aurez alors pas du tout d’information décrivant la base… : manipuler la base de données : en identifiant d’abord le format des données, en sélectionnant un champ différent (moins de lignes/d’observations), et/ou des variables spécifiques (moins de colonnes/d’informations), avec les fonctions filter(), select(), subset(), pivot_wider(), pivot_longer(), unique(), arrange(), etc.; manipuler des variables : en identifiant le format des variables, en les mettant dans le bon format, en (re)travaillant les modalités d’une variable qualitative (avec notamment les fonctions mutate(), case_when(), as.factor(), ou encore celles du package factors), en détectant/visualisant/gérant les valeurs manquantes d’une variable quantitative avec entre autres le package naniar, en détectant/visualiant/gérant les valeurs aberrantes d’une variable quantitative à partir en particulier des statistiques de la “boîte à moustaches” (fonction geom_boxplot() à utiliser avec ggplot(), fonction boxplot.stats()), et enfin, en transformant une variable quantitative en variable qualitative (avec les fonctions cut() et fancycut()). L’usage pour cette phase du langage dplyr ou plus généralement du tidyverse est particulièrement conseillée, cela permet d’“enchaîner” des fonctions en une seule instruction. 4.2 Enregistrement des tables Et voilà, on a bien “trituré” ces deux bases de données, maintenant on peut les enregistrer dans notre projet pour pouvoir les réutiliser lors de la prochaine séance. # On enregistre les tables de données pour les utiliser ultérieurement saveRDS(object = RP_final, file = &quot;data/RP_final.Rdata&quot;) saveRDS(object = meta, file = &quot;data/meta.Rdata&quot;) saveRDS(object = dvf_Paris, file = &quot;data/dvf_Paris_1.Rdata&quot;) "],["05-Questions-fouille-donnees.html", "Section 5 Quelles questions intéressantes pour une “fouille de données” sur cette base ? 5.1 Caractéristiques de la population résidant à Paris 5.2 Caractéristiques de la population active résidant à Paris 5.3 Caractéristiques des logements parisiens", " Section 5 Quelles questions intéressantes pour une “fouille de données” sur cette base ? Quelles sont les questions intéressantes que l’on peut se poser ? Qu’est-ce qu’on va pouvoir mettre en évidence à partir de ces données ? D’abord, on peut caractériser la population de Paris et sa petite couronne selon des variables socio-démographiques (sexe, âge, diplôme, statut conjugal, nombre d’enfants, …) et d’emploi (statut d’activité, PCS, condition d’emploi - contrat, temps de travail -, secteur d’activité, …). Ensuite, on peut décrire les logements de Paris et sa petite couronne, selon le type (appartement, maison, HLM, …), la superficie, le nombre de pièces, le nombre de personnes y habitant, le statut d’occupation (propriétaire, locataire, …), l’ancienneté d’occupation. Enifn, on peut décrire plus précisément les pièces du logement en termes de confort (baignoire / douche, salle climatisée, moyen de chauffage), ainsi que les parties communes de l’immeuble (ascenseur, place de stationnement). Enfin, on pourrait étudier les caractéristiques des occupants de ces logements, et en premier lieu ici ce que l’Insee appelle la “personne de référence du ménage”. Par ailleurs, toutes ces analyses peuvent être réalisées en comparant les différentes communes de Paris et sa petite couronne, ou à un niveau géographique plus fin par quartiers, arrondissements ou encore IRIS. Pour manipuler cette base et répondre à quelques-unes de ces questions, nous allons nous concentrer sur la commune de Paris, et allons chercher à reproduire des statistiques publiées sur le site de l’Insee. Nous produirons principalement, lors de cette séance, des tableaux de statistiques, l’analyse graphique fera en effet l’objet de la séance suivante car elle nécessite la présentation détaillée de la “grammaire” Ggplot. Avant cela, si les tables de données (“RP_final” et “meta”) ne sont plus dans votre environnement local, il faut de nouveau les importer à partir de l’enregistrement précédemment effectué dans le dossier ‘data’ de votre projet. Pour cela, il faut utiliser la fonction readRDS(), comme ci-dessous : 5.1 Caractéristiques de la population résidant à Paris Sur le site de l’Insee, vous pouvez trouver les statistiques générales sur les individus à Paris en 2019 ici et là. Comme déjà vu lors de la 1ère séance, l’application de la pondération pour avoir des statistiques représentatives de la population peut être utilisée à l’intérieur de la fonction count() avec l’argument wt=. Cela nous donnera le nombre d’individus concernés par la caractéristique étudiée (par défaut, la variable créée s’appelle “n”, on peut la renommer dans une étape ultérieure avec la fonction rename()). Souvent, on souhaite aussi avoir les pourcentages, on peut alors créer une variable rapportant le nombre de chaque catégorie sur le nombre total d’individus, avec la fonction prop.table() utilisée dans la fonction mutate(). Le package janitor peut permettre enfin d’ajouter une ligne totale (ou une colonne totale selon ce qu’on souhaite faire) avec la fonction adorn_totals(), argument “row” pour avoir le total en ligne ou “col” pour l’avoir en colonne.Des fonctions supplémentaires liées au package gt() peuvent ensuite être utilisées pour mettre en forme le tableau : fmt_number(), tab_header() ou encore tab_source_note(). A partir de ces indications, afficher le tableau suivant à partir d’un code utilisant le langage tidyverse et en une seule procédure (sans créer de table dans votre environnement) : #dybxqiiezu table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #dybxqiiezu thead, #dybxqiiezu tbody, #dybxqiiezu tfoot, #dybxqiiezu tr, #dybxqiiezu td, #dybxqiiezu th { border-style: none; } #dybxqiiezu p { margin: 0; padding: 0; } #dybxqiiezu .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #dybxqiiezu .gt_caption { padding-top: 4px; padding-bottom: 4px; } #dybxqiiezu .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #dybxqiiezu .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #dybxqiiezu .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #dybxqiiezu .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #dybxqiiezu .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #dybxqiiezu .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #dybxqiiezu .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #dybxqiiezu .gt_column_spanner_outer:first-child { padding-left: 0; } #dybxqiiezu .gt_column_spanner_outer:last-child { padding-right: 0; } #dybxqiiezu .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #dybxqiiezu .gt_spanner_row { border-bottom-style: hidden; } #dybxqiiezu .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #dybxqiiezu .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #dybxqiiezu .gt_from_md > :first-child { margin-top: 0; } #dybxqiiezu .gt_from_md > :last-child { margin-bottom: 0; } #dybxqiiezu .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #dybxqiiezu .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #dybxqiiezu .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #dybxqiiezu .gt_row_group_first td { border-top-width: 2px; } #dybxqiiezu .gt_row_group_first th { border-top-width: 2px; } #dybxqiiezu .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #dybxqiiezu .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #dybxqiiezu .gt_first_summary_row.thick { border-top-width: 2px; } #dybxqiiezu .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #dybxqiiezu .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #dybxqiiezu .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #dybxqiiezu .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #dybxqiiezu .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #dybxqiiezu .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #dybxqiiezu .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #dybxqiiezu .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #dybxqiiezu .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #dybxqiiezu .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #dybxqiiezu .gt_left { text-align: left; } #dybxqiiezu .gt_center { text-align: center; } #dybxqiiezu .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #dybxqiiezu .gt_font_normal { font-weight: normal; } #dybxqiiezu .gt_font_bold { font-weight: bold; } #dybxqiiezu .gt_font_italic { font-style: italic; } #dybxqiiezu .gt_super { font-size: 65%; } #dybxqiiezu .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #dybxqiiezu .gt_asterisk { font-size: 100%; vertical-align: 0; } #dybxqiiezu .gt_indent_1 { text-indent: 5px; } #dybxqiiezu .gt_indent_2 { text-indent: 10px; } #dybxqiiezu .gt_indent_3 { text-indent: 15px; } #dybxqiiezu .gt_indent_4 { text-indent: 20px; } #dybxqiiezu .gt_indent_5 { text-indent: 25px; } Population par sexe en 2019 Sexe Effectif Pourcentage Femmes 1 146 436 52.9 Hommes 1 019 195 47.1 Total 2 165 631 100.0 Source : Insee, RP 2019 ; Champ : Paris. library(tidyverse) library(janitor) library(gt) RP_final %&gt;% filter(DEPT == &quot;75&quot;) %&gt;% mutate(SEXE_moda=case_when(SEXE==&quot;1&quot; ~ &quot;Hommes&quot;, SEXE==&quot;2&quot; ~ &quot;Femmes&quot;)) %&gt;% count(SEXE_moda, wt=IPONDI) %&gt;% mutate(Pourcentage=round(prop.table(n)*100, 1)) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% rename(Effectif=n, &#39;Sexe&#39;=SEXE_moda) %&gt;% gt() %&gt;% fmt_number(columns = 2, sep_mark = &quot; &quot;, decimals = 0) %&gt;% tab_source_note(source_note = &quot;Source : Insee, RP 2019 ; Champ : Paris.&quot;) %&gt;% tab_header(title = &quot;Population par sexe en 2019&quot;) Il y a plus de femmes habitant Paris en 2019, environ 53%. Cherchons maintenant la répartition de la population parisienne par type d’activité : quelle est la proportion d’actifs ayant un emploi par rapport à la part des chômeurs ou encore des retraites ? Attention au champ sur lequel porte ces statistiques (lire le titre du tableau pour cela…). #blcnjicnfg table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #blcnjicnfg thead, #blcnjicnfg tbody, #blcnjicnfg tfoot, #blcnjicnfg tr, #blcnjicnfg td, #blcnjicnfg th { border-style: none; } #blcnjicnfg p { margin: 0; padding: 0; } #blcnjicnfg .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #blcnjicnfg .gt_caption { padding-top: 4px; padding-bottom: 4px; } #blcnjicnfg .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #blcnjicnfg .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #blcnjicnfg .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #blcnjicnfg .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #blcnjicnfg .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #blcnjicnfg .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #blcnjicnfg .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #blcnjicnfg .gt_column_spanner_outer:first-child { padding-left: 0; } #blcnjicnfg .gt_column_spanner_outer:last-child { padding-right: 0; } #blcnjicnfg .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #blcnjicnfg .gt_spanner_row { border-bottom-style: hidden; } #blcnjicnfg .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #blcnjicnfg .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #blcnjicnfg .gt_from_md > :first-child { margin-top: 0; } #blcnjicnfg .gt_from_md > :last-child { margin-bottom: 0; } #blcnjicnfg .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #blcnjicnfg .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #blcnjicnfg .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #blcnjicnfg .gt_row_group_first td { border-top-width: 2px; } #blcnjicnfg .gt_row_group_first th { border-top-width: 2px; } #blcnjicnfg .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #blcnjicnfg .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #blcnjicnfg .gt_first_summary_row.thick { border-top-width: 2px; } #blcnjicnfg .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #blcnjicnfg .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #blcnjicnfg .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #blcnjicnfg .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #blcnjicnfg .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #blcnjicnfg .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #blcnjicnfg .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #blcnjicnfg .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #blcnjicnfg .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #blcnjicnfg .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #blcnjicnfg .gt_left { text-align: left; } #blcnjicnfg .gt_center { text-align: center; } #blcnjicnfg .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #blcnjicnfg .gt_font_normal { font-weight: normal; } #blcnjicnfg .gt_font_bold { font-weight: bold; } #blcnjicnfg .gt_font_italic { font-style: italic; } #blcnjicnfg .gt_super { font-size: 65%; } #blcnjicnfg .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #blcnjicnfg .gt_asterisk { font-size: 100%; vertical-align: 0; } #blcnjicnfg .gt_indent_1 { text-indent: 5px; } #blcnjicnfg .gt_indent_2 { text-indent: 10px; } #blcnjicnfg .gt_indent_3 { text-indent: 15px; } #blcnjicnfg .gt_indent_4 { text-indent: 20px; } #blcnjicnfg .gt_indent_5 { text-indent: 25px; } Population de 15-64 ans par type d'activité en 2019 Type d'activité Effectif Pourcentage Actifs ayant un emploi 1 042 588 69.3 Chômeurs 135 014 9.0 Élèves, étudiants et stagiaires non rémunérés 192 205 12.8 Retraités ou préretraités 38 512 2.6 Autres inactifs 95 944 6.4 Total 1 504 263 100.1 Source : Insee, RP 2019 ; Champ : Paris. RP_final %&gt;% filter(DEPT == &quot;75&quot; &amp; !AGEREVQ %in% c(&quot;0&quot;, &quot;5&quot;, &quot;10&quot;, &quot;65&quot;, &quot;70&quot;, &quot;75&quot;, &quot;80&quot;, &quot;85&quot;, &quot;90&quot;, &quot;95&quot;, &quot;100&quot;, &quot;105&quot;, &quot;110&quot;, &quot;115&quot;, &quot;120&quot;)) %&gt;% mutate(TACT_moda1=case_when(TACT == &quot;11&quot; ~ &quot;Actifs ayant un emploi&quot;, TACT == &quot;12&quot; ~ &quot;Chômeurs&quot;, TACT == &quot;22&quot; ~ &quot;Élèves, étudiants et stagiaires non rémunérés&quot;, TACT == &quot;21&quot; ~ &quot;Retraités ou préretraités&quot;, TRUE ~ &quot;Autres inactifs&quot;), TACT_moda1=fct_relevel(TACT_moda1, c(&quot;Actifs ayant un emploi&quot;, &quot;Chômeurs&quot;, &quot;Élèves, étudiants et stagiaires non rémunérés&quot;, &quot;Retraités ou préretraités&quot;, &quot;Autres inactifs&quot;))) %&gt;% count(TACT_moda1, wt=IPONDI) %&gt;% mutate(Pourcentage=round(prop.table(n)*100,1)) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% rename(Effectif=n, &quot;Type d&#39;activité&quot;=TACT_moda1) %&gt;% gt() %&gt;% fmt_number(columns = 2, sep_mark = &quot; &quot;, decimals = 0) %&gt;% tab_header(title = &quot;Population de 15-64 ans par type d&#39;activité en 2019&quot;) %&gt;% tab_source_note(source_note = &quot;Source : Insee, RP 2019 ; Champ : Paris.&quot;) En 2019, la population parisienne comportait plus de 78% d’actifs dont 69% ayant un emploi et 9% au chômage, le taux de chômage à Paris était donc de 11,5% (135014/(1042588+135014))*100). La part des étudiants ou autres élèves était plus élevée que celle des retraités (ou préretaités) : 12,8% contre 2,6%. 5.2 Caractéristiques de la population active résidant à Paris Maintenant, affichons les deux dernières colonnes (‘2019’ et ‘dont actifs ayant un emploi’) de ce tableau tiré du site de l’Insee, en mettant la ligne “Ensemble” plutôt en fin de tableau (ces 2 usages sont possibles, question de préférence…). Attention encore une fois au champ de ce tableau… Pour cela, on va : récupérer les libellés des modalités de la variable cS1 à partir du fichier ‘meta’, en créant 2 vecteurs correspondant aux modalités pour le 1er et aux libellés pour le 2nd, puis en créant une variable ‘CS1_moda’ à partir de ces vecteurs ; créer une 1ère table qu’on appellera ‘col2’ qui comportera la 1ère colonne avec les intitulés des PCS et la colonne ‘2019’, attention, il y a une modalité qui ne nous intéresse pas car non affiché dans le tableau de l’Insee, il faudra supprimer cette ligne (vous pouvez utiliser pour cela la fonction slice()) ; créer une 2ème table qu’on appellera ‘col3’ qui comportera la 1ère colonne avec les intitulés des PCS et la colonne ‘dont actifs ayant un emploi’, attention le champ n’est donc pas tout à fait le même ; joindre ces deux tables et appliquer les fonctions gt() et suivantes pour la mise en forme du tableau final. # On va récupérer les libellés des modalités de la variable CS1 à partir du fichier meta : levels_CS1 &lt;- meta[meta$COD_VAR==&quot;CS1&quot;, ]$COD_MOD labels_CS1 &lt;- meta[meta$COD_VAR==&quot;CS1&quot;, ]$LIB_MOD RP_final &lt;- RP_final %&gt;% mutate(CS1_moda=factor(CS1, levels = levels_CS1, labels = labels_CS1)) col2 &lt;- RP_final %&gt;% filter(DEPT == &quot;75&quot; &amp; !AGEREVQ %in% c(&quot;0&quot;, &quot;5&quot;, &quot;10&quot;, &quot;65&quot;, &quot;70&quot;, &quot;75&quot;, &quot;80&quot;, &quot;85&quot;, &quot;90&quot;, &quot;95&quot;, &quot;100&quot;, &quot;105&quot;, &quot;110&quot;, &quot;115&quot;, &quot;120&quot;) &amp; TACT %in% c(&quot;11&quot;, &quot;12&quot;)) %&gt;% count(CS1_moda, wt=IPONDI) %&gt;% mutate(n=round(n)) %&gt;% rename(&#39;2019&#39;=n, &#39;PCS&#39;=CS1_moda) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% slice(-7) col3 &lt;- RP_final %&gt;% filter(DEPT == &quot;75&quot; &amp; !AGEREVQ %in% c(&quot;0&quot;, &quot;5&quot;, &quot;10&quot;, &quot;65&quot;, &quot;70&quot;, &quot;75&quot;, &quot;80&quot;, &quot;85&quot;, &quot;90&quot;, &quot;95&quot;, &quot;100&quot;, &quot;105&quot;, &quot;110&quot;, &quot;115&quot;, &quot;120&quot;) &amp; TACT %in% c(&quot;11&quot;)) %&gt;% count(CS1_moda, wt=IPONDI) %&gt;% mutate(n=round(n)) %&gt;% rename(&#39;dont actifs ayant un emploi&#39;=n, &#39;PCS&#39;=CS1_moda) %&gt;% adorn_totals(&quot;row&quot;) col2 %&gt;% left_join(col3) %&gt;% gt() %&gt;% fmt_number(columns = c(2,3), sep_mark = &quot; &quot;, decimals = 0) %&gt;% tab_header(title = &quot;Population active de 15-64 ans selon la catégorie socioprofessionnelle en 2019&quot;) %&gt;% tab_source_note(source_note = &quot;Source : Insee, RP 2019 ; Champ : Paris.&quot;) # On supprime les tableaux intermédiaires rm(col2, col3) A Paris, la population active comprend en 2019 plus de 500 000 personnes appartenant à la catégorie “cadres et professions intellectuelles supérieures”, des 2 colonnes on peut en déduire qu’il y a environ 31 000 personnes relevant de cette PCS qui sont au chômage. Les cadres sont suivis des professions intermédiaires (plus de 260 000 actifs) et des employés (quasi 220 000). Il y a très peu d’agriculteurs exploitants, ce qui semble assez logique sur le territoire de Paris ! 5.3 Caractéristiques des logements parisiens Enfin, pour donner un exemple sur l’étude des caractéristiques des logements parisients, essayons de même de reproduire le tableau de l’Insee ci-dessous. Souvenez-vous que cette base a plusieurs unités statistiques/niveaux : individus, logements/ménages, etc. Il faut donc faire attention : au champ du tableau donc les filtres à utiliser ici ; à avoir d’abord les moyennes sur ces deux types de logements, donc uiliser à la suite les fonctions group_by() et summarise() ; à ajouter ensuite une ligne sur l’ensemble des résidences principales avec la fonction bind_rows() ; à changer les dénominations des colonnes et des modalités, avec les fonctions du package gt() comme cols_label() ou text_case_match(). RP_final %&gt;% filter(DEPT == &quot;75&quot; &amp; LPRM==&quot;1&quot; &amp; CATL==&quot;1&quot; &amp; TYPL %in% c(&quot;1&quot;, &quot;2&quot;)) %&gt;% group_by(TYPL) %&gt;% summarise(Moy_pieces = weighted.mean(as.numeric(as.character(NBPI)), IPONDI, na.rm=T)) %&gt;% bind_rows(summarise(TYPL = &quot;Ensemble des résidences principales&quot;, RP_final[RP_final$DEPT == &quot;75&quot; &amp; RP_final$LPRM==&quot;1&quot; &amp; RP_final$CATL == &quot;1&quot; &amp; RP_final$TYPL %in% c(&quot;1&quot;, &quot;2&quot;), ], Moy_pieces = weighted.mean(as.numeric(as.character(NBPI)), IPONDI, na.rm=T))) %&gt;% gt() %&gt;% fmt_number(columns = 2, dec_mark = &quot;,&quot;, decimals = 1) %&gt;% cols_label(TYPL=&quot;Type de logement&quot;, Moy_pieces=&quot;2019&quot;) %&gt;% text_case_match(&quot;1&quot; ~ &quot;Maison&quot;, &quot;2&quot; ~ (&quot;Appartements&quot;)) %&gt;% tab_header(title = &quot;Nombre moyen de pièces des résidences principales&quot;) %&gt;% tab_source_note(source_note = &quot;Source : Insee, RP 2019 ; Champ : Paris.&quot;) Ainsi, si l’on veut créer des tableaux de répartition à une seule variable, on peut utiliser ces procédures qui se structurent toujours de la même façon. Au lieu de faire un copié-collé du code et de changer le nom des variables, autrement dit pour systématiser nos procédures, une astuce est de créer ses propres fonctions. C’est ce que nous allons étudier maintenant. "],["06-Fonctions.html", "Section 6 Systématiser nos procédures : construire une fonction 6.1 Principes généraux d’une fonction 6.2 Exemples de fonctions", " Section 6 Systématiser nos procédures : construire une fonction Pour ré-utiliser un code de façon plus automatique, créer des fonctions est très utile (et on peut même les stocker dans un fichier .r pour les réutiliser plus tard pour une autre étude). 6.1 Principes généraux d’une fonction L’idée est qu’à partir d’un bloc d’instructions ou de lignes de codes, on l’intègre dans une fonction qui portera un nom et qui pourra être appliquée sur les paramètres que l’on veut (table/objet différent, variables différentes) et qui nous retournera une valeur en sortie (qu’il faut préciser donc). Par exemple : # Exemple fonction avec 3 arguments nom_fonction &lt;- function(data, var1, var2) { expression... # Ce que la fonction fait return() # Optionnel, mais la plupart du temps utilisé (!), # pour sortir le résultat de la fonction } # L&#39;appel de la fonction devra ainsi préciser la table de données sur laquelle # l&#39;appliquer et les autres arguments : nom_fonction(data = nom_de_ma_table , var1 = nom_de_ma_variable1, var2 = nom_de_ma_variable2) # De plus, on pourra créer un nouvel objet (ici &quot;tab_var&quot;) pour stocker la table # qui est en valeur de sortie de la fonction : tab_var &lt;- nom_fonction(data = nom_de_ma_table , var1 = nom_de_ma_variable1, var2 = nom_de_ma_variable2) Les arguments doivent donc être précisés en entrée de notre fonction, si on ne les précise pas cela nous retournera une erreur… à moins que l’on ait spécifié des valeurs par défaut (ce qui peut être utile si on utilise souvent les mêmes paramètres, par exemple la même base de données) ; il peut y avoir autant d’arguments que l’on souhaite. Si l’on utilise le langage tidyverse, il faut connaître quelques petits “trucs” pour écrire une fonction. Le schéma suivant réalisé par Julien Barnier du CNRS nous sera très utile. Pour une fonction utilisant le langage tidyverse Source : Julien Barnier, https://twitter.com/lapply/status/1493908215796535296?s=20&amp;t=p4aYIEV4GsGS3TGftPa0Nw. Vous trouverez également des informations utiles ici ou là. 6.2 Exemples de fonctions On peut d’abord créer une fonction reprenant le code de la section précédente pour la construction de tableau. On l’appelle tableau, et on lui donne comme arguments “data”, “filtre_com”, “var_quali”, “pond” et “nom_var_quali”. Dans le langage tidyverse, au sein d’une fonction, il faut appeler une variable avec des doubles-accolades {{ }}. Si l’on utilise une fonction summarise(), une autre subtilité à connaître est que cette syntaxe summarise({{ nom_var }} = mean({{ var }}, na.rm=TRUE)) ne sera pas reconnue, car il faut indiquer non pas un = mais un := pour que la fonction puisse être lue lorsque le nom donné à la variable est de type caractère ou “string”. Enfin, il ne faut pas oublier de retourner un objet en sortie avec return(). Essayez donc de créer une fonction tableau(), reprenant le premier code de la section précédente et remise ci-dessous pour information : RP_final %&gt;% filter(DEPT == &quot;75&quot;) %&gt;% mutate(SEXE_moda=case_when(SEXE==&quot;1&quot; ~ &quot;Hommes&quot;, SEXE==&quot;2&quot; ~ &quot;Femmes&quot;)) %&gt;% count(SEXE_moda, wt=IPONDI) %&gt;% mutate(Pourcentage=round(prop.table(n)*100, 1)) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% rename(Effectif=n, &#39;Sexe&#39;=SEXE_moda) %&gt;% gt() %&gt;% fmt_number(columns = 2, sep_mark = &quot; &quot;, decimals = 0) %&gt;% tab_header(title = &quot;Population par sexe en 2019&quot;) %&gt;% tab_source_note(source_note = &quot;Source : Insee, RP 2019 ; Champ : Paris.&quot;) tableau &lt;- function(data, filtre_dept, var_quali, pond=IPONDI, nom_var_quali){ tab &lt;- data %&gt;% filter(DEPT == filtre_dept) %&gt;% count({{ var_quali }}, wt={{ pond }}) %&gt;% mutate(Pourcentage=prop.table(n)*100, Pourcentage=round(Pourcentage, 1)) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% rename(Effectif=n, {{nom_var_quali}}:={{ var_quali }}) return(tab) } On peut vérifier qu’on obtient bien la même chose : RP_final %&gt;% mutate(SEXE_moda=case_when(SEXE==&quot;1&quot; ~ &quot;Hommes&quot;, SEXE==&quot;2&quot; ~ &quot;Femmes&quot;)) %&gt;% tableau(filtre_dept=&quot;75&quot;, var_quali=SEXE_moda, nom_var_quali=&quot;Sexe&quot;) %&gt;% gt() %&gt;% fmt_number(columns = 2, sep_mark = &quot; &quot;, decimals = 0) %&gt;% tab_header(title = &quot;Population par sexe en 2019&quot;) %&gt;% tab_source_note(source_note = &quot;Source : Insee, RP 2019 ; Champ : Paris.&quot;) #spreplshdx table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #spreplshdx thead, #spreplshdx tbody, #spreplshdx tfoot, #spreplshdx tr, #spreplshdx td, #spreplshdx th { border-style: none; } #spreplshdx p { margin: 0; padding: 0; } #spreplshdx .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #spreplshdx .gt_caption { padding-top: 4px; padding-bottom: 4px; } #spreplshdx .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #spreplshdx .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #spreplshdx .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #spreplshdx .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #spreplshdx .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #spreplshdx .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #spreplshdx .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #spreplshdx .gt_column_spanner_outer:first-child { padding-left: 0; } #spreplshdx .gt_column_spanner_outer:last-child { padding-right: 0; } #spreplshdx .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #spreplshdx .gt_spanner_row { border-bottom-style: hidden; } #spreplshdx .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #spreplshdx .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #spreplshdx .gt_from_md > :first-child { margin-top: 0; } #spreplshdx .gt_from_md > :last-child { margin-bottom: 0; } #spreplshdx .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #spreplshdx .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #spreplshdx .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #spreplshdx .gt_row_group_first td { border-top-width: 2px; } #spreplshdx .gt_row_group_first th { border-top-width: 2px; } #spreplshdx .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #spreplshdx .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #spreplshdx .gt_first_summary_row.thick { border-top-width: 2px; } #spreplshdx .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #spreplshdx .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #spreplshdx .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #spreplshdx .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #spreplshdx .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #spreplshdx .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #spreplshdx .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #spreplshdx .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #spreplshdx .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #spreplshdx .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #spreplshdx .gt_left { text-align: left; } #spreplshdx .gt_center { text-align: center; } #spreplshdx .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #spreplshdx .gt_font_normal { font-weight: normal; } #spreplshdx .gt_font_bold { font-weight: bold; } #spreplshdx .gt_font_italic { font-style: italic; } #spreplshdx .gt_super { font-size: 65%; } #spreplshdx .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #spreplshdx .gt_asterisk { font-size: 100%; vertical-align: 0; } #spreplshdx .gt_indent_1 { text-indent: 5px; } #spreplshdx .gt_indent_2 { text-indent: 10px; } #spreplshdx .gt_indent_3 { text-indent: 15px; } #spreplshdx .gt_indent_4 { text-indent: 20px; } #spreplshdx .gt_indent_5 { text-indent: 25px; } Population par sexe en 2019 Sexe Effectif Pourcentage Femmes 1 146 436 52.9 Hommes 1 019 195 47.1 Total 2 165 631 100.0 Source : Insee, RP 2019 ; Champ : Paris. On a gagné 5 lignes de codes ! Si on a plusieurs filtres à mettre, comme on a pu le voir avec le 2nd tableau, on peut utiliser l’argument “…” (lire “dot”) : cet argument est très pratique si l’on ne sait pas combien il y aura de variable(s) dans la fonction à laquelle elle s’applique, c’est-à-dire autant 0 variable, 1 variable ou plus d’une variable ; mais elle peut aussi être “dangereuse” si on ne se souvient plus qu’on l’a créée et/ou si on ne fait pas attention à bien remplir les autres arguments avec les noms correspondants. Si on réécrit la fonction tableau et qu’on l’applique au 2nd tableau créé précédemment, cela donnerait ceci : tableau &lt;- function(data, ..., var_quali, pond=IPONDI, nom_var_quali){ tab &lt;- data %&gt;% filter(...) %&gt;% count({{ var_quali }}, wt={{ pond }}) %&gt;% mutate(Pourcentage=prop.table(n)*100, Pourcentage=round(Pourcentage, 1)) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% rename(Effectif=n, {{nom_var_quali}}:={{ var_quali }}) return(tab) } RP_final %&gt;% mutate(TACT_moda1=case_when(TACT == &quot;11&quot; ~ &quot;Actifs ayant un emploi&quot;, TACT == &quot;12&quot; ~ &quot;Chômeurs&quot;, TACT == &quot;22&quot; ~ &quot;Élèves, étudiants et stagiaires non rémunérés&quot;, TACT == &quot;21&quot; ~ &quot;Retraités ou préretraités&quot;, TRUE ~ &quot;Autres inactifs&quot;), TACT_moda1=fct_relevel(TACT_moda1, c(&quot;Actifs ayant un emploi&quot;, &quot;Chômeurs&quot;, &quot;Élèves, étudiants et stagiaires non rémunérés&quot;, &quot;Retraités ou préretraités&quot;, &quot;Autres inactifs&quot;))) %&gt;% tableau(DEPT == &quot;75&quot; &amp; !AGEREVQ %in% c(&quot;0&quot;, &quot;5&quot;, &quot;10&quot;, &quot;65&quot;, &quot;70&quot;, &quot;75&quot;, &quot;80&quot;, &quot;85&quot;, &quot;90&quot;, &quot;95&quot;, &quot;100&quot;, &quot;105&quot;, &quot;110&quot;, &quot;115&quot;, &quot;120&quot;), var_quali=TACT_moda1, nom_var_quali=&quot;Type d&#39;activité&quot;) %&gt;% gt() %&gt;% fmt_number(columns = 2, sep_mark = &quot; &quot;, decimals = 0) %&gt;% tab_header(title = &quot;Population de 15-64 ans par type d&#39;activité en 2019&quot;) %&gt;% tab_source_note(source_note = &quot;Source : Insee, RP 2019 ; Champ : Paris.&quot;) #owvzjapxtp table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #owvzjapxtp thead, #owvzjapxtp tbody, #owvzjapxtp tfoot, #owvzjapxtp tr, #owvzjapxtp td, #owvzjapxtp th { border-style: none; } #owvzjapxtp p { margin: 0; padding: 0; } #owvzjapxtp .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #owvzjapxtp .gt_caption { padding-top: 4px; padding-bottom: 4px; } #owvzjapxtp .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #owvzjapxtp .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #owvzjapxtp .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #owvzjapxtp .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #owvzjapxtp .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #owvzjapxtp .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #owvzjapxtp .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #owvzjapxtp .gt_column_spanner_outer:first-child { padding-left: 0; } #owvzjapxtp .gt_column_spanner_outer:last-child { padding-right: 0; } #owvzjapxtp .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #owvzjapxtp .gt_spanner_row { border-bottom-style: hidden; } #owvzjapxtp .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #owvzjapxtp .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #owvzjapxtp .gt_from_md > :first-child { margin-top: 0; } #owvzjapxtp .gt_from_md > :last-child { margin-bottom: 0; } #owvzjapxtp .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #owvzjapxtp .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #owvzjapxtp .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #owvzjapxtp .gt_row_group_first td { border-top-width: 2px; } #owvzjapxtp .gt_row_group_first th { border-top-width: 2px; } #owvzjapxtp .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #owvzjapxtp .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #owvzjapxtp .gt_first_summary_row.thick { border-top-width: 2px; } #owvzjapxtp .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #owvzjapxtp .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #owvzjapxtp .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #owvzjapxtp .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #owvzjapxtp .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #owvzjapxtp .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #owvzjapxtp .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #owvzjapxtp .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #owvzjapxtp .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #owvzjapxtp .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #owvzjapxtp .gt_left { text-align: left; } #owvzjapxtp .gt_center { text-align: center; } #owvzjapxtp .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #owvzjapxtp .gt_font_normal { font-weight: normal; } #owvzjapxtp .gt_font_bold { font-weight: bold; } #owvzjapxtp .gt_font_italic { font-style: italic; } #owvzjapxtp .gt_super { font-size: 65%; } #owvzjapxtp .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #owvzjapxtp .gt_asterisk { font-size: 100%; vertical-align: 0; } #owvzjapxtp .gt_indent_1 { text-indent: 5px; } #owvzjapxtp .gt_indent_2 { text-indent: 10px; } #owvzjapxtp .gt_indent_3 { text-indent: 15px; } #owvzjapxtp .gt_indent_4 { text-indent: 20px; } #owvzjapxtp .gt_indent_5 { text-indent: 25px; } Population de 15-64 ans par type d'activité en 2019 Type d'activité Effectif Pourcentage Actifs ayant un emploi 1 042 588 69.3 Chômeurs 135 014 9.0 Élèves, étudiants et stagiaires non rémunérés 192 205 12.8 Retraités ou préretraités 38 512 2.6 Autres inactifs 95 944 6.4 Total 1 504 263 100.1 Source : Insee, RP 2019 ; Champ : Paris. Une autre façon de faire serait de créer un vecteur qui contiendrait ces différents filtres mais qu’il faudrait combiner dans une chaîne de caractères, ce qui est possible avec la fonction paste0(), et l’insérer ensuite dans la ligne de code dplir en utilisant eval(parse(text=)) pour convertir cette chaîne de caractéres en une expression (parse(text=)) pour que R puisse l’évaluer/le calculer avec la fonction eval(). tableau_bis &lt;- function(data, vars_filtre, var_quali, pond=IPONDI, nom_var_quali){ text_filtre &lt;- paste0(&quot;(&quot;, vars_filtre, &quot;)&quot;, collapse = &quot; &amp; &quot;) tab1 &lt;- data %&gt;% filter(eval(parse(text = text_filtre))) %&gt;% count({{ var_quali }}, wt={{ pond }}) %&gt;% mutate(Pourcentage=prop.table(n)*100, Pourcentage=round(Pourcentage, 1)) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% rename(Effectif=n, {{nom_var_quali}}:={{ var_quali }}) return(tab1) } # Attention, comme les filtres sont contenues dans des &quot; &quot;, il faut à l&#39;intérieur des filtres utiliser les &#39; &#39; plutôt que les &quot; &quot; mes_filtres &lt;- c(&quot;DEPT == &#39;75&#39;&quot;, &quot;!AGEREVQ %in% c(&#39;0&#39;, &#39;5&#39;, &#39;10&#39;, &#39;65&#39;, &#39;70&#39;, &#39;75&#39;, &#39;80&#39;, &#39;85&#39;, &#39;90&#39;, &#39;95&#39;, &#39;100&#39;, &#39;105&#39;, &#39;110&#39;, &#39;115&#39;, &#39;120&#39;)&quot;) RP_final %&gt;% mutate(TACT_moda1=case_when(TACT == &quot;11&quot; ~ &quot;Actifs ayant un emploi&quot;, TACT == &quot;12&quot; ~ &quot;Chômeurs&quot;, TACT == &quot;22&quot; ~ &quot;Élèves, étudiants et stagiaires non rémunérés&quot;, TACT == &quot;21&quot; ~ &quot;Retraités ou préretraités&quot;, TRUE ~ &quot;Autres inactifs&quot;), TACT_moda1=fct_relevel(TACT_moda1, c(&quot;Actifs ayant un emploi&quot;, &quot;Chômeurs&quot;, &quot;Élèves, étudiants et stagiaires non rémunérés&quot;, &quot;Retraités ou préretraités&quot;, &quot;Autres inactifs&quot;))) %&gt;% tableau_bis(mes_filtres, var_quali=TACT_moda1, nom_var_quali=&quot;Type d&#39;activité&quot;) %&gt;% gt() %&gt;% fmt_number(columns = 2, sep_mark = &quot; &quot;, decimals = 0) %&gt;% tab_header(title = &quot;Population de 15-64 ans par type d&#39;activité en 2019&quot;) %&gt;% tab_source_note(source_note = &quot;Source : Insee, RP 2019 ; Champ : Paris.&quot;) On peut également créer une fonction pour permettre de récupérer plus rapidement les libellés des variables à partir du fichier de métadonnées : # Pour la fonction mutate, on est de nouveau obligé d&#39;utiliser l&#39;expression &#39;eval(parse(text={{ cod_var }}))&#39; sinon R ne # comprend pas que la variable utilisée est une expression de type caractère libelles_var &lt;- function(data, cod_var, new_var){ levels_var &lt;- meta[meta$COD_VAR=={{ cod_var }}, ]$COD_MOD labels_var &lt;- meta[meta$COD_VAR=={{ cod_var }}, ]$LIB_MOD data %&gt;% mutate({{ new_var }} := factor(eval(parse(text={{ cod_var }})), levels = levels_var, labels = labels_var)) } # Autre possibilité, utiliser la fonction `sym()` (qui crée un symbole à partir # d&#39;une chaîne de caractères) avec les &quot;!!&quot; (opérateur bang-bang qui permet de # forcer l&#39;évaluation d&#39;une partie d&#39;une expression avant le reste) : # libelles_var &lt;- function(data, cod_var, new_var){ # # levels_var &lt;- meta[meta$COD_VAR=={{ cod_var }}, ]$COD_MOD # labels_var &lt;- meta[meta$COD_VAR=={{ cod_var }}, ]$LIB_MOD # data %&gt;% mutate({{ new_var }} := factor(!!sym({{ cod_var }}), levels = levels_var, labels = labels_var)) # # } Enfin, essayez d’écrire une seconde fonction somme() permettant de systématiser le code utilisée en fin de 1ère séance et qui donnait un tableau de contingence du nombre de personnes caractériées par son statut par commune (cela nous servira pour plus tard…) ; le voici pour rappel : RP_final %&gt;% group_by(COM) %&gt;% count(TACT_moda, wt=IPONDI) %&gt;% mutate(n=round(n)) %&gt;% pivot_wider(names_from = TACT_moda, values_from = n) somme &lt;- function(data, var_gpe, nom_var){ som &lt;- data %&gt;% group_by({{var_gpe}}) %&gt;% count({{nom_var}}, wt=IPONDI) %&gt;% mutate(n=round(n)) %&gt;% pivot_wider(names_from = {{nom_var}}, values_from = n) return(som) } Vérifions : somme(data=RP_final, COM, TACT_moda) # A tibble: 137 × 5 COM `Actifs en emploi` Chômeurs Retraités `Autres inactifs` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 75101 8366 941 2630 3979 2 75102 13118 1378 2148 4964 3 75103 19239 2085 4589 8123 4 75104 15227 1863 4508 7513 5 75105 27378 2611 10607 17618 6 75106 18073 1842 8180 12176 7 75107 23394 2165 9573 13735 8 75108 18254 1565 5297 10534 9 75109 34155 3482 7264 15125 10 75110 46454 6343 10645 23078 # ℹ 127 more rows La création de fonctions est donc très utile pour avoir un code plus efficace ; il faut toutefois réfléchir à son usage avant de la créer pour savoir à quel point il faut systématiser les procédures utilisées, certains éléments devant être laissés probablement en-dehors de la fonction, comme dans l’exemple précédent le fait d’arrondir les chiffres. Il faut par ailleurs toujours vérfier, sur un ou deux exemples, que la fonction fonctionne bien, c’est-à-dire donne les mêmes résultats que le code initial. Pour pouvoir les réutiliser ultérieurement, on peut les réécrire dans un nouveau script qu’on enregistre dans un dossier de notre projet qu’on intitule “fonctions” ; il suffira ensuite d’appeler ce programme avec la fonction source() : source(&quot;fonctions/fonctions.R&quot;) "],["07-Ggplot-theorique.html", "Section 7 Data Visualization et Ggplot2 : aspects théoriques 7.1 Présentation générale de Ggplot2 7.2 Les grands principes de data visualization", " Section 7 Data Visualization et Ggplot2 : aspects théoriques 7.1 Présentation générale de Ggplot2 Le package ggplot2 (inclus dans le package tidyverse) est l’un des atouts de R et permet de réaliser de beaux graphiques ; vous en trouverez ici la présentation officielle. L’inconvénient, surtout pour quelqu’un qui serait habitué à construire des graphiques sous excel, est qu’il faut (presque) tout paramétrer, ce qui peut finalement donner un code très long. L’architecture globale de ggplot2 est souvent représentée par le schéma ci-dessous : Pour le lire, il faut partir du bas du schéma : par “Data”, nous devons d’abord préciser la base ou le tableau de données utilisé(e) qui contient la ou les variables qui seront représentées ; par “aesthetics”, nous allons ensuite indiquer les variables qui seront projetées sur le graphe ; par “geometries”, nous indiquons le type de graphique utilisé ou la forme géométrique ; par “facets”, nous pouvons éventuellement (facultatif donc) diviser ou découper le graphique en plusieurs graphes (ou “panneaux”) dépendant d’une autre variable par exemple ; par “statistics”, nous pouvons là aussi éventuellement ajouter des statistiques ; par “coordinates”, nous pouvons là aussi éventuellement changer le sens du graphique ; enfin, par “theme”, nous pouvons utiliser éventuellement l’un des thèmes graphiques diponibles et/ou ajouter un certain nombre d’options sur ce qui “entoure” le graphique, c’est-à-dire les positions et/ou couleurs et/ou taille, etc., des axes, titre, légende, etc. 7.1.1 Les “aesthetics” ou arguments esthétiques Il s’agit principalement d’indiquer quelle variable sera utilisée en abcisse (x=), et laquelle sera éventuellement utilisée en ordonnée (y=). Mais on peut aussi ajouter des variables supplémentaires qui seront différenciées par : couleur, avec color= (pour des points, lignes ou symboles) ou fill= (pour le contenu des bâtons ou symboles) ; taille avec size= ; symboles avec shape= ; type de lignes avec linetype= ; degré de transparence avec alpha= (mais non conseillé pour les variables discrètes). La nuance à bien comprendre est qu’utiliser ces options à l’intérieur de la fonction aes() revient à ajouter une 3ème variable (une légende apparaîtra alors automatiquement), alors que si l’on veut simplement changer l’aspect des points, lignes, barres, etc., d’une variable déjà projetée, il faut appeler (souvent) ces mêmes options après la fonction aes() à l’intérieur de la fonction geom_***() par exemple. Dans ce cas-là, on peut changer la couleur des points avec color= , la taille des points ou lignes avec size=, l’épaisseur des barres avec width=, etc. C’est la différence entre le “mapping” et les “settings”. Chacune de ces options ont des modalités différentes, il peut être bien d’avoir des mémos rangés dans un dossier créé pour cela pour éviter de les chercher à chaque fois. Par exemple, pour les couleurs, vous trouverez un mémo pdf ici, ou un bon récapitulatif là. On peut également utiliser la fonction colours() dans R pour voir la liste complète des couleurs standard. Pour la liste des symboles (“shape”) et le numéro correspondant que l’on appelera avec l’argument shape=, ci-dessous un récapitulatif : Et voici pour la liste des types de lignes, avec linetype= : 7.1.2 Les géométries Une fois les variables appelées, il faut définir le type de graphique. Il y a beaucoup de choix possibles inclus dans ggplot2, le tout est de bien comprendre quel type de graphique convient le mieux à ou aux variables utilisées et à ce que l’on veut montrer (cf. section suivante sur les grands principes de la data visualization). Voici un tableau récapitulant les principales “geometries”. Tableau : Les principales fonctions “geometries” de Ggplot Fonction Type de graphique Type de variable(s) geom_histogram() Histogramme 1 variable continue geom_density() Courbe de densité 1 variable continue geom_area() Graphique en aires empilées 1 variable continue geom_col() Graphique en bâtons 1 variable discrète geom_point() Nuage de points 2 variables continues geom_jitter() Nuage de points dispersés 2 variables continues geom_boxplot() Boîte à moustache 1 variable continue, sans ou avec 1 variable discrète geom_violin() Graphes en violon 1 variable continue, sans ou avec 1 variable discrète geom_bar() Graphique en bâtons 1 variable continue, sans ou avec 1 variable discrète geom_line() Lignes Fonction continue selon une variable de date geom_area() Graphique en aires empilées Fonction continue selon une variable de date Certaines d’entre elles ont des options à préciser, presque de façon obligatoire comme nous l’avons déjà vu avec geom_histogram() et l’option bins=, si elle n’est pas précisée, elle sera “forcée” par R mais un message d’avertissement en rouge apparaîtra. Il en existe bien sûr plein d’autres, il faut dans ce cas rechercher sur internet ou aller voir sur la “cheatsheet” de ggplot2 disponible sur internet. Il est possible de faire suivre plusieurs fonctions geom_***() : par exemple un geom_line() après un geom_point(), un geom_text() après un geom_bar(), etc. Dans ce cas, des variables supplémentaires peuvent être ajoutées (ou remplacer les précédentes) avec une nouvelle fonction aes à l’intérieur de ce geom_***() ; un exemple assez courant est la construction d’un graphique en bâtons avec l’ajout des valeurs de la variable à l’intérieur des bâtons (ou juste au-dessus), on fera alors appel à deux fonction geom_***() comme ceci : data %&gt;% ggplot() + aes(x=, y=) + geom_bar() + geom_text(aes(label=)). De même, il est possible de spécifier des données (data) différentes pour chaque geom_***() . 7.1.3 Les facettes Il y a deux types de facettes (en réalité trois, avec celle par défaut qui s’intitule facet_null() et produit un seul graphe) : facet_wrap() : produit une suite de graphiques et a un argument principal facets=vars() et éventuellement ncol= et nrow= ; facet_grid() : produit une grille ou matrice de graphiques définies par une ou deux variables qui forment les lignes et les colonnes, définies avec les deux arguments principaux cols= et row=, ou en indiquant un ~ entre les deux variables. À savoir, il y a des options pour contrôler les échelles avec l’argument scales=. Les facettes sont ainsi une autre façon, par rapport aux “aesthetics”, de représenter deux variables par rapport à une troisième variable. 7.1.4 Les statistiques On peut vouloir ajouter sur un graphique des statistiques particulières ou supplémentaires, comme la moyenne ou médiane d’une variable quantitative, ou encore représenter la régression linéaire dans le cas d’une variable fonction d’une autre, etc. Par exemple, si l’on projette des boîtes à moustache, la moyenne n’étant pas affichée on peut la rajouter avec la fonction stat_summary() et l’option fun = mean. Si l’on souhaite ajouter une régression linéaire sur un graphique de nuage de points, il faut utiliser la fonction geom_smooth() et l’option method=lm. Certaines statistiques peuvent aussi être calculées ou transformées directement dans certaines fonctions : c’est par exemple le cas avec la fonction geom_histogramm() où l’on peut produire un histogramme de la densité en spécifiant y=..density.. dans l’aes() ou en la superposant à l’aide d’une courbe à l’histogramme initial en ajoutant alors ensuite un geom_density() ; ou encore avec la fonction geom_bar() avec les arguments stat = \"summary_bin\", fun = mean (par défaut, stat = \"count\", dans ce cas la hauteur des barres représente le comptage des cas dans chaque catégorie). 7.1.5 Les coordonnées Les systèmes de coordonnées linéaires permettent de changer le sens du graphique ou de “zoomer” sur le graphique : coord_cartesian() : c’est le système de coordonnées par défaut (repère “cartésien”), en changeant les arguments xlim= ou ylim=, on procède à un zoom sur l’axe des abscisses et/ou celui des ordonnées ; cela permet de ne pas supprimer des données comme le ferait les fonctions scale_x_continuous() ou scale_y_continuous mais juste de ne pas les afficher sur le graphe ; coord_flip() : permet d’inverser les axes ; coord_fixed() : produit un système de coordonnées cartésiennes avec un “ratio d’aspect” fixe. Il existe également des systèmes de coordonnées non-linéaires, comme coord_polar() par exemple. 7.1.6 Les thèmes Il y a plusieurs thèmes existants dans le package ggplot2, theme_gray() est le thème par défaut ; les autres sont présentés dans la figure ci-dessous. Ensuite, la fonction theme() permet de modifier les aspects du graphique : il y a un certain nombre d’arguments disponibles qui permettent de modifier les éléments entourant le graphique comme les titre et sous-titre, les éléments à l’intérieur du graphique c’est-à-dire de la grille, les éléments des axes, ou encore les éléments de la légende (ou sa position sur la figure), etc. La figure ci-dessous est une bonne synthèse de la manière dont il faut programmer ces différentes éléments du thème d’un graphique (téléchargeable directement ici) : 7.1.7 Les autres options graphiques : titres, échelles des axes, etc. Pour le titre général, mais aussi les titres des axes, ainsi qu’une éventuelle légende, source, etc., on peut les rassembler dans la fonction labs() : labs( title = &quot; &quot;, subtitle = &quot; &quot;, x = &quot; &quot;, y = &quot; &quot;, caption = &quot; &quot;) Les axes des échelles peuvent être changés, ainsi que les valeurs affichées, avec les fonctions scale : si les variables sont quantitatives/continues, avec scale_x_continous() et scale_y_continuous() ; si les variables sont qualitatives/discrètes, avec scale_x_discrete() et scale_x_discrete() ; dont les options les plus souvent utilisées sont limits=, breaks=, labels=, ou encore trans= qui permet de transformer la mesure de l’échelle (exponentielle, log, …). Lorsqu’une option fill= ou color= est utilisée dans un aes, alors on peut modifier le type de couleurs ou palettes utilisées avec par exemple scale_fill_brewer() pour la pallette de couleur RBrewer ou scale_fill_viridis() pour la palette Viridis, etc. Il y a encore d’autres fonctions qui permettent de “customiser” à votre goût un graphique ggplot, il faut s’aventurer dans les diverses documentations plus complètes sur le package ggplot2. 7.1.8 Code minimal Après l’appel de la fonction ggplot(), chaque “couche” supplémentaire utilisée est précisée par le signe + et non l’habituel pipe %&gt;% pour bien signifier qu’on est toujours dans la fonction ggplot(), par ailleurs il faut faire attention de mettre le signe + à la fin d’une ligne et ensuite de faire un saut de ligne (le contraire saut de ligne et début de la ligne suivante avec le + ne fonctionnera pas). Les trois arguments obligatoires sont donc les 3 premières : “data”, “aesthethics” et “geometries”. En langage tidyverse, il existe plusieurs façons d’écrire le code : # Les 4 façons d&#39;écrire suivantes sont similaires : data %&gt;% # on spécifie la table de données ggplot() + # on appelle la fonction ggplot() aes(x = , y = ) + # on spécifie dans l&#39;aes() les variables à mettre dans l&#39;axe # des abcisses (x=) et dans l&#39;axe des ordonnées (y=) geom_histogram() # on trace l&#39;histogramme data %&gt;% ggplot(aes(x = , y = )) + geom_histogram() ggplot(data) + aes(x = , y = ) + geom_histogram() ggplot(data, aes(x = , y = )) + geom_histogram() Nous privilégierons ici la 1ère d’entre elles, mais vous pouvez en choisir une autre ! 7.1.9 Liens utiles pour aller plus loin Nous ne pouvons pas résumer l’ensemble des possibilités données par ggplot2 ; il faudra donc rechercher par soi-même si besoin. Voici pour cela deux sites très complets sur le package : https://ggplot2-book.org/toolbox.html https://bookdown.org/ael/rexplor/chap8.html#aes 7.2 Les grands principes de data visualization Sans prétendre, ni pouvoir, faire un cours complet de data visualization, voici quelques grands principes à essayer de respecter quand on souhaite représenter graphiquement des résultats issus du traitement de données : savoir au préalable le message principal que l’on souhaite faire passer : cela peut sembler évident, mais il faut toujour avoir cela en tête ; construire un graphique intelligible par le plus grand nombre : des graphiques trop sophistiqués, trop chargés d’informations, etc., ne permettront pas de transmettre le message souhaité. Cela peut bien sûr varier selon le public, mais… ; situer le graphique : avec un titre explicite, éventuellement un sous-titre, ensuite avec une légende reprenant le champ et/ou la source, etc. ; choisir le “bon” graphique selon le type de variables à représenter : variable continue ou discrète, croisement d’un type de variable avec un autre type, variables dépendant du temps (évolution), etc. ; présenter le graphique de manière la plus objective possible : ne pas “tordre” le graphique pour faire apparaître un résultat qui n’est pas si évident que cela (c’est typiquement l’exemple d’un changement d’échelle ; d’un “zoom” sur l’axe des ‘y’ sur un graphique en évolution par exemple, pour montrer des variations qui ne seraient pas visibles si l’axe commençait à 0) ; rajouter des informations (étiquettes de nom, valeur, etc.) sans trop surcharger le graphique néanmoins ; être logique dans la contruction des éléments extérieurs au graphe : par exemple, ordre des modalités d’une légende située à droite selon le point d’arrivée des courbes ; ordre des modalités d’une variable discrète (par exemple le niveau de diplôme) ou selon la moyenne/médiane d’une autre variable par ordre croissant ou décroissant ; utiliser (le plus possible) des axes similaires pour comparer deux grahes côte à cote. Ce chapitre de cours donne des conseils synthétiques : cf. ici ; ou cet article-là. "],["08-Ggplot-pratique.html", "Section 8 Data Mining et Data Visualization en pratique 8.1 Exemple de la construction d’un graphique pas à pas 8.2 D’autres exemples à travers des exercices", " Section 8 Data Mining et Data Visualization en pratique Reprenons la base de données sur les demandes de valeurs foncières sur laquelle nous avons travaillé dans la section 3, et commençons notre analyse descriptive des informations présentes dans cette base en construisant des graphiques pour répondre à certaines questions relatives aux prix auquels se sont vendus les appartements de la ville de Paris entre 2019 et 2022. On pourra ainsi étudier l’évolution dans le temps de ces prix. # Appelons la table si elle n&#39;est pas déjà dans votre environnement dvf_Paris_1 &lt;- readRDS(&quot;data/dvf_Paris_1.Rdata&quot;) # Rappel des variables présentes et de leurs noms names(dvf_Paris_1) [1] &quot;id_mutation&quot; &quot;date_mutation&quot; [3] &quot;nature_mutation&quot; &quot;valeur_fonciere&quot; [5] &quot;code_postal&quot; &quot;id_parcelle&quot; [7] &quot;lot1_numero&quot; &quot;lot1_surface_carrez&quot; [9] &quot;lot2_numero&quot; &quot;lot2_surface_carrez&quot; [11] &quot;nombre_lots&quot; &quot;type_local&quot; [13] &quot;surface_reelle_bati&quot; &quot;nombre_pieces_principales&quot; [15] &quot;surface_terrain&quot; &quot;px_m2&quot; [17] &quot;annee&quot; &quot;date_moisan&quot; [19] &quot;p_1&quot; &quot;p_99&quot; [21] &quot;nom_arrdt&quot; 8.1 Exemple de la construction d’un graphique pas à pas On va chercher à représenter la distribution du prix du m2 des ventes d’appartements en fonction de l’année. Notre variable principale est donc px_m2, et la variable “secondaire” ou fonction de la première est annee. Pour représenter la distribution d’une variable quantitative ou continue, on peut utiliser un histogramme (ou/et une courbe de densité), mais comme ici on veut la représenter selon une autre variable peut-être serait-il mieux d’utiliser une boîte à moustache qui donnera les principaux éléments de description de la distribution de cette variable. Nous avons déjà vu ces deux graphiques précédemment, mais reprenons-les pour voir dans le détail comment nous les construisons ! D’abord, on va créer une boîte à moustache pour représenter la distribution de la variable px_m2: library(tidyverse) dvf_Paris_1 %&gt;% ggplot() + aes(x = px_m2) + geom_boxplot() Comme il reste des valeurs aberrantes (cf. section 3.2.3. de la séance 1 de ce cours), il faut faire un minimum d’élagage sur cette variable, ce qu’on n’avait pas fait à la fin de cette séance. On va ainsi supprimer les observations pour lesquelles le prix au m2 est supérieur au 1% de la distribution et inférieur au 99% de la distribution, mais en faisant attention à prendre la distribution selon l’année pour que cela soit plus précis. Voici comment faire : # On peut d&#39;abord regarder quelles sont ces valeurs avec la ligne de code suivante : # dvf_Paris_1 %&gt;% group_by(annee) %&gt;% mutate(p_1=quantile(px_m2, 0.01), #p_99=quantile(px_m2, 0.99)) %&gt;% select(annee, p_1, p_99) %&gt;% unique() # On crée 2 variables selon l&#39;année et on filtre ensuite, attention à utiliser le # &quot;ungroup()&quot; à la fin, en particulier parce qu&#39;on remplace la base. dvf_Paris_1 &lt;- dvf_Paris_1 %&gt;% group_by(annee) %&gt;% mutate(p_1=quantile(px_m2, 0.01), p_99=quantile(px_m2, 0.99)) %&gt;% filter(px_m2&gt;p_1 &amp; px_m2&lt;p_99) %&gt;% ungroup() # Vérifions les statistiques maintenant : dvf_Paris_1 %&gt;% group_by(annee) %&gt;% get_summary_stats(px_m2) # A tibble: 4 × 14 annee variable n min max median q1 q3 iqr mad mean sd &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2019 px_m2 24712 40.1 63660. 10000 8333. 11838. 3505. 2577. 10809. 6287. 2 2020 px_m2 35426 136. 49820 10714. 9091. 12610. 3519. 2592. 11460. 5218. 3 2021 px_m2 46737 129. 61364. 11000 9429. 12857. 3429. 2500. 11893. 6134. 4 2022 px_m2 35683 257. 72778. 10912. 9375 12895. 3520. 2539. 12111. 6524. # ℹ 2 more variables: se &lt;dbl&gt;, ci &lt;dbl&gt; Cela semble plus propre, et on a supprimé 2 981 observations. On va pouvoir maintenant créer nos graphiques. dvf_Paris_1 %&gt;% ggplot() + aes(x = px_m2) + geom_boxplot() Il y a toujours pas mal de valeurs aberrantes ce qui ne rend pas très lisible le graphique. Pour éviter de supprimer encore des observations, on va utiliser une option pour mettre une échelle moins grande en abcisse. Plusieurs manières de faire existent, mais l’une d’entre elles équivaut à supprimer les valeurs, alors qu’une autre permet de les garder et juste de ne pas les faire apparaître sur le graphique, cela peut-être important si ensuite nous voulons ajoutons des statistiques comme la moyenne sur le boxplot, comme nous allons le voir. La première manière est d’utiliser l’argument scale_x_continuous() et l’option limits=c() pour indiquer les nouvelles valeurs de l’échelle, par exemple ici entre 3 000 et 21 000, mais un avertissement est alors donné : 13 652 lignes ont donc été supprimées (sur 145 487 initiales), si nous ajoutons ensuite la moyenne, elle sera calculée sans ces 13 652 observations, cela peut donc changer les indicateurs de moyenne, voire de médiane, ce n’est donc pas rigoureux. Utilisons plutôt la seconde méthode maintenant, avec l’option xlim() à intégrer dans la fonction coord_cartesian() qui fait l’équivalent d’un zoom sur le graphique : # 1ère méthode : # dvf_Paris_1 %&gt;% ggplot() + aes(x = px_m2) + geom_boxplot() # + scale_x_continuous(limits = c(3000, 21000)) # 2nde méthode plus rigoureuse : dvf_Paris_1 %&gt;% ggplot() + aes(x = px_m2) + geom_boxplot() + coord_cartesian(xlim=c(3000,21000)) Ensuite, nous souhaitons représenter la distribution de cette variable selon l’année) : nous allons pour cela ajouter dans l’aes() une variable y= qui doit, attention, être définie en factor, sinon les niveaux/modalités de la variable ne sont pas reconnu(e)s ; et nous allons en profiter pour préciser un peu l’échelle des abscisses (réduire le “pas” avec l’option breaks=seq()) : dvf_Paris_1 %&gt;% ggplot() + aes(x = px_m2, y=annee) + geom_boxplot() + coord_cartesian(xlim=c(3000,21000)) + scale_x_continuous(breaks=seq(3000,21000,2000)) On voit une augmentation de la médiane entre 2019 et 2021 puis une très légère baisse ou quasi-stagnation en 2022. Nous pouvons également ajouter la moyenne, puisqu’ici nous voyons de gauche à droite, le minimum, le 1er quartile, la médiane, le 3ème quartile, le maximum et les “outliers” (points aberrants selon les statistiques de la boxplot). Pour cela, il faut utiliser la “couche” statistique de ggplot() avec la fonction stat_summary() et les options fun = mean pour la moyenne, geom = point pour qu’elle soit représentée par un point, color=\"gray50\" pour qu’elle se différencie des autres points et soit en gris, et éventuellement size=2 pour jouer sur la taille du point. # Pour infos, les options de `geom =` dans `stat_summary()` sont par exemple : # &quot;point&quot;, &quot;pointrange&quot;, &quot;crossbar&quot;, &quot;bar&quot; (cell-ci à ne pas utiliser ici néanmoins !) dvf_Paris_1 %&gt;% ggplot() + aes(x = px_m2, y=annee) + geom_boxplot() + stat_summary(fun=mean, geom=&quot;point&quot;, color=&quot;gray50&quot;, size=2) + coord_cartesian(xlim=c(3000,21000)) + scale_x_continuous(breaks=seq(3000,21000,2000)) On observe ainsi des différences entre la moyenne et la médiane, puisqu’ici la moyenne ne cesse d’augmenter y compris entre 2021 et 2022 ; la moyenne est toujours supérieure à la médiane puisque tirée par des valeurs plus souvent très élevées que très faibles (plus de points au-delà du maximum que l’inverse). On peut aussi vouloir enlever les outliers avec l’option outlier.shape de geom_boxplot() comme ceci : geom_boxplot(outlier.shape = NA). On peut vouloir encore ordonner l’affichage des années par ordre décroissant de la médiane ou de la moyenne (ordre décroissant ici = valeur la plus élevée en haut du graphique). Nous pouvons, entre autres, utiliser pour cela la fonction fct_reorder() du package forcats déjà présenté dans la section 3.2 de ce cours (Séance 1) : nous pouvons alors directement l’intégrer dans l’aes de ggplot dans la variable en ordonnée y=fct_reorder(), il faut alors entre parenthèses mettre la variable utilisée en ordonnée, suivie de la variable par laquelle on ordonne (la même que celle utilisée dans x=). Utilisée dans un boxplot, cela ordonne par défaut selon la médiane ; si on veut que les régions soient ordonnées par la moyenne, il faut rajouter l’option .fun=mean dans la fonction fct_reorder(), cf. le code en-dessous. dvf_Paris_1 %&gt;% ggplot() + aes(x = px_m2, y=fct_reorder(annee, px_m2)) + geom_boxplot() + stat_summary(fun=mean, geom=&quot;point&quot;, color=&quot;gray50&quot;, size=2) + coord_cartesian(xlim=c(3000,21000)) + scale_x_continuous(breaks=seq(3000,21000,2000)) # dvf_Paris_1 %&gt;% # ggplot() + # aes(x = px_m2, y=fct_reorder(annee, px_m2), .fun=mean) + # geom_boxplot() + # stat_summary(fun=mean, geom=&quot;point&quot;, color=&quot;gray50&quot;, size=2) + # coord_cartesian(xlim=c(3000,21000)) + # scale_x_continuous(breaks=seq(3000,21000,2000)) Attention, comme ici notre seconde variable est l’année, cela n’est pas forcément pertinent de modifier l’ordre du graphique pour le mettre selon la moyenne car cela pourrait perturber la lecture du graphique. On va revenir sur le graphique précédent donc. Nous arrivons à un graphique intéressant, il faut maintenant améliorer la description autour : noms des axes, titres, légende informative sous le graphique (avec notamment un avertissement sur les valeurs non affichées sur le graphique), éventuellement un peu de couleur (avec fill= non pas dans l’aes() mais dans la fonction geom_boxplot() pour qu’elle soit identique quel que soit le département), etc. Cela se fait avec la fonction labs(), et ensuite la fonction theme(). Une petite astuce pour les titres pour qu’ils ne soient pas coupés sur le graphe : \\n collé à un mot (sans espace) permet de mettre à la ligne à partir de ce mot ! dvf_Paris_1 %&gt;% ggplot() + aes(x = px_m2, y=fct_reorder(annee, px_m2)) + geom_boxplot(outlier.shape = NA, fill=&quot;khaki&quot;) + stat_summary(fun=mean, geom=&quot;point&quot;, color=&quot;gray50&quot;, size=2) + coord_cartesian(xlim=c(3000,21000)) + scale_x_continuous(breaks=seq(3000,21000,2000)) + labs(title=&quot;Distribution du prix au m2 des ventes d&#39;appartements dans Paris sur la période 2019-2022&quot;, x=&quot;Prix au m2&quot;, y=&quot;Année&quot;, caption=&quot;Remarques : Les valeurs en-dessous de 3 000€ et au-dessus de 21 000€ au m2 ne sont pas affichées ; les points \\nau-delà du minimum et maximum non plus ; les points en gris représentent la moyenne. \\nSource : Base &#39;demande de valeurs foncières&#39;, 2019-2022. \\nCalculs : Camille Signoretto.&quot;) + theme(plot.caption = element_text(hjust=0), plot.title = element_text(size=11.5), axis.title.x = element_text(size=10), axis.title.y = element_text(size=10)) Voilà un premier graphique construit avec la grammaire de ggplot(). À vous maintenant de construire vous-mêmes les graphiques qui vous sont suggérés dans la section suivante ! 8.2 D’autres exemples à travers des exercices 8.2.1 Distribution du prix au m2 pour les appartements parisiens, selon l’année Construisez le même type de graphique mais cette fois à partir d’une densité de distribution selon de même l’année. N’hésitez pas à changer les options pour le mettre à votre goût !! dvf_Paris_1 %&gt;% ggplot() + aes(x = px_m2, fill=annee) + geom_density(alpha = 0.4, color=NA) + coord_cartesian(xlim=c(3000,21000)) + labs(title=&quot;Distribution du prix au m2 des ventes d&#39;appartements dans Paris sur la période 2019-2022&quot;, x=&quot;Prix au m2&quot;, y=&quot; &quot;, fill= &quot;Année&quot;, caption=&quot;Remarques : Les valeurs en-dessous de 3 000€ et au-dessus de 21 000€ au m2 ne sont pas affichées. \\nSource : Base &#39;demande de valeurs foncières&#39;, 2019-2022. \\nCalculs : Camille Signoretto.&quot;) + theme(plot.caption = element_text(hjust=0), plot.title = element_text(size=12), axis.title.x = element_text(size=10), axis.title.y = element_text(size=10)) 8.2.2 Comparaison des montants moyen et médian du prix au m2, par arrondissement de Paris Construisez maintenant un graphique mettant l’un en-dessous de l’autre deux graphes en bâtons représentant respectivement le prix au m2 moyen et le prix au m2 médian des ventes d’appartements par arrondissement. Pour vous aider si besoin, réfléchissez par étapes : non obligatoire, mais il est bien de commencer par créer une variable avec les noms réduit des arrondissements et non le code postal ; créer un premier graphe que vous assignerez à un nouvel objet et qui représentera celui de la moyenne par arrondissement ; vous pouvez pour cela créer une nouvelle variable qui constituera la moyenne pour chaque département (un conseil : arrondir à l’unité) ; sélectionnez les variables qui seront utilisées dans le graphique et vérifier (ou corriger sinon) qu’il n’y ait pas des doublons (lignes identiques) car cela peut fausser le graphique ensuite ; construisez le graphique avec ggplot() et la bonne fonction geom_***(), les données doivent être affichées par ordre décroissant ; faîtes de même pour la médiane par arrondissement ; vous pouvez ensuite mettre ces graphiques côte à côté avec le package patchwork (qu’il vous faudra probablement installer si c’est la première fois que vous l’utilisez), recherchez sur internet comment faire ensuite (c’est très simple !), puis ajoutez un titre et une légende générale avec la fonction plot_annotation(). dvf_Paris_1 &lt;- dvf_Paris_1 %&gt;% mutate(nom_arrdt=as.factor(case_when(code_postal==75001 ~ &quot;1er arrdt&quot;, code_postal==75002 ~ &quot;2e arrdt&quot;, code_postal==75003 ~ &quot;3e arrdt&quot;, code_postal==75004 ~ &quot;4e arrdt&quot;, code_postal==75005 ~ &quot;5e arrdt&quot;, code_postal==75006 ~ &quot;6e arrdt&quot;, code_postal==75007 ~ &quot;7e arrdt&quot;, code_postal==75008 ~ &quot;8e arrdt&quot;, code_postal==75009 ~ &quot;9e arrdt&quot;, code_postal==75010 ~ &quot;10e arrdt&quot;, code_postal==75011 ~ &quot;11e arrdt&quot;, code_postal==75012 ~ &quot;12e arrdt&quot;, code_postal==75013 ~ &quot;13e arrdt&quot;, code_postal==75014 ~ &quot;14e arrdt&quot;, code_postal==75015 ~ &quot;15e arrdt&quot;, code_postal==75016 ~ &quot;16e arrdt&quot;, code_postal==75017 ~ &quot;17e arrdt&quot;, code_postal==75018 ~ &quot;18e arrdt&quot;, code_postal==75019 ~ &quot;19e arrdt&quot;, code_postal==75020 ~ &quot;20e arrdt&quot;))) p1 &lt;- dvf_Paris_1 %&gt;% filter(!is.na(code_postal)) %&gt;% group_by(nom_arrdt) %&gt;% mutate(moy_prixm2 = round(mean(px_m2),0)) %&gt;% select(moy_prixm2, nom_arrdt) %&gt;% unique() %&gt;% ggplot() + aes(x = fct_reorder(nom_arrdt, desc(moy_prixm2)), y = moy_prixm2) + geom_bar(stat=&quot;identity&quot;, fill=&quot;honeydew&quot;) + geom_text(aes(label = moy_prixm2), position = position_stack(vjust = 0.5), color=&quot;gray25&quot;, size=2.8) + labs(title = &quot;Moyenne&quot;, x = &quot; &quot;, y = &quot; &quot;) + theme(axis.text.x = element_text(angle=90, hjust=1, size=9), plot.title = element_text(size=10.5)) p2 &lt;- dvf_Paris_1 %&gt;% filter(!is.na(code_postal)) %&gt;% group_by(nom_arrdt) %&gt;% mutate(median_prixm2 = round(median(px_m2),0)) %&gt;% select(median_prixm2, nom_arrdt) %&gt;% unique() %&gt;% ggplot() + aes(x = fct_reorder(nom_arrdt, desc(median_prixm2)), y = median_prixm2) + geom_bar(stat=&quot;identity&quot;, fill=&quot;honeydew&quot;) + geom_text(aes(label = median_prixm2), position = position_stack(vjust = 0.5), color=&quot;gray25&quot;, size=2.8) + labs(title = &quot;Médiane&quot;, x = &quot; &quot;, y = &quot; &quot;) + theme(axis.text.x = element_text(angle=90, hjust=1, size=9), plot.title = element_text(size=10.5)) library(patchwork) (p1 / p2) + plot_annotation(title = &quot;Montants moyens et médians du prix au m2 des ventes d&#39;appartements sur Paris, selon \\nl&#39;arrondissement sur la période 2019-2022&quot;, caption = &quot;Source : Base &#39;demande de valeurs foncières&#39;, 2019-2022. \\nCalculs : Camille Signoretto.&quot;, theme = theme(plot.title = element_text(size = 12), plot.caption = element_text(hjust = 0))) On observe que les 4ème, 6ème, 7ème et 8ème arrondissements sont les plus chers, que ce soit en moyenne ou en médiane, même si le classement change légèrement selon les deux indicateurs. Il faut vraiment se demander quel type de public serait visé par ces informations, si c’est le grand public, la moyenne et la médiane suffisent si l’on veut montrer qu’il y a quand même une certaine dispersion des valeurs selon les ventes, souvent seule la moyenne étant représentée. On aurait pu sinon utilser un “dot plot”, comme ci-dessous. Cherchez comment l’on peut construire ce type de graphique (rq : cela ne correspond par à une fonction en tant que telle). Le début du code est le même, ce sont les fonctions geom_*** qui changent… library(&quot;ggrepel&quot;) p3 &lt;- dvf_Paris_1 %&gt;% filter(!is.na(code_postal)) %&gt;% group_by(nom_arrdt) %&gt;% mutate(moy_prixm2 = round(mean(px_m2),0)) %&gt;% select(moy_prixm2, nom_arrdt) %&gt;% unique() %&gt;% ggplot() + aes(x = moy_prixm2, y = fct_reorder(nom_arrdt, moy_prixm2)) + geom_point(color=&quot;burlywood4&quot;, size=2) + geom_segment(aes(x=0, xend=moy_prixm2, y=fct_reorder(nom_arrdt, moy_prixm2), yend=fct_reorder(nom_arrdt, moy_prixm2)), color=&quot;snow4&quot;) + geom_text_repel(aes(label = moy_prixm2), size = 3) + labs(title = &quot;Prix au m2 moyen&quot;, x = &quot; &quot;, y = &quot; &quot;) + theme(plot.title = element_text(size=10), axis.text.y = element_text(size=9)) p4 &lt;- dvf_Paris_1 %&gt;% filter(!is.na(code_postal)) %&gt;% group_by(nom_arrdt) %&gt;% mutate(median_prixm2 = round(median(px_m2),0)) %&gt;% select(median_prixm2, nom_arrdt) %&gt;% unique() %&gt;% ggplot() + aes(x = median_prixm2, y = fct_reorder(nom_arrdt, median_prixm2)) + geom_point(color=&quot;burlywood4&quot;, size=2) + geom_segment(aes(x=0, xend=median_prixm2, y=fct_reorder(nom_arrdt, median_prixm2), yend=fct_reorder(nom_arrdt, median_prixm2)), color=&quot;snow4&quot;) + geom_text_repel(aes(label = median_prixm2), size = 3) + labs(title = &quot;Prix au m2 médian&quot;, x = &quot; &quot;, y = &quot; &quot;) + theme(plot.title = element_text(size=10), axis.text.y = element_text(size=9)) (p3 + p4) + plot_annotation(title = &quot;Montants moyens et médians du prix au m2 des ventes d&#39;appartements sur Paris, selon \\nl&#39;arrondissement sur la période 2019-2022&quot;, caption = &quot;Source : Base &#39;demande de valeurs foncières&#39;, 2019-2022. \\nCalculs : Camille Signoretto.&quot;, theme = theme(plot.title = element_text(size = 12), plot.caption = element_text(hjust = 0))) 8.2.3 Evolution du prix médian au m2 des ventes d’appartements à Paris Changeons un peu de perspective et construisez cette fois un graphique montrant l’évolution du prix médian au m2 des ventes d’appartements à Paris, de manière générale et ensuite selon 6 arrondissements choisis selon leur prix médian mis en avant un peu plus haut : les 3 ayant les prix les plus élevés (6ème, 7ème et 4ème arrondissement), et les 3 ayant les prix les moins élevés (13ème, 19ème et 20ème arrdt). On peut voir le rendre interactif de telle sorte que l’utilisateur puisse voir les valeurs des points en passant la souris dessus : pour cela, il faut installer et charge le package plotly puis utiliserla fonction ggplotly() ; cela nécessite de stocker le graphique dans un objet. De même, il faut procéder par étapes : créer ensuite la variable de prix médian au m2 selon l’année ; ne garder que ces variables, supprimer les lignes doublons le cas échéant ; construir un graphique sous forme de courbes avec des points représentants les valeurs en le stockant dans un objet ; appeler la fonction ggplotly() en utilisant l’argument tooltip() pour que seule la valeur des “y” soit affichée.. g_evo &lt;- dvf_Paris_1 %&gt;% group_by(annee) %&gt;% mutate(med_prixm2 = round(median(px_m2),0)) %&gt;% select(med_prixm2, annee) %&gt;% unique() %&gt;% ggplot() + aes(x=factor(annee), y=med_prixm2) + geom_point() + geom_line(group=1) + scale_y_continuous(limits=c(6000,12000), breaks = seq(6000,12000,500)) + labs(title = &quot;Evolution du prix médian au m2 des appartements vendus à Paris&quot;, x = &quot; &quot;, y = &quot; &quot;) + theme(plot.title = element_text(size=12), plot.caption = element_text(hjust=0)) #install.packages(&quot;plotly&quot;) library(plotly) ggplotly(g_evo, tooltip = c(&quot;med_prixm2&quot;)) %&gt;% layout(margin = list(l = 50, r = 50, b = 80, t = 50), annotations = list(text = &quot;Source : base &#39;demande de valeurs foncières&#39;, 2019-2022. \\nCalculs : Camille Signoretto. \\nNote : l&#39;axe des ordonnées ne commence qu&#39;à 6000€.&quot;, showarrow = F, x = 0, y = -0.2, xref=&#39;paper&#39;, yref=&#39;paper&#39;, xanchor=&#39;left&#39;, yanchor=&#39;auto&#39;, xshift=0, yshift=0, font=list(size=10.5), align=&quot;left&quot;)) On retrouve un résultat que l’on avait observé précédemment avec la boxplot, à savoir que le prix médian au m2 des appartements vendus à Paris a augmenté entre 2019 et 2021, puis légèrement baissé. Regardons maintenant selon quelques arrondissements de Paris (dans les 6 mentionnés au-dessus), pour étudier si cette évolution est différente selon la position de l’arrondissement dans l’échelle des prix médians. g_evo_pls &lt;- dvf_Paris_1 %&gt;% filter(nom_arrdt %in% c(&quot;4e arrdt&quot;,&quot;6e arrdt&quot;,&quot;7e arrdt&quot;,&quot;13e arrdt&quot;,&quot;19e arrdt&quot;,&quot;20e arrdt&quot;)) %&gt;% group_by(annee, nom_arrdt) %&gt;% mutate(med_prixm2 = round(median(px_m2),0)) %&gt;% select(med_prixm2, annee, nom_arrdt) %&gt;% unique() %&gt;% mutate(nom_arrdt=factor(nom_arrdt, levels = c(&quot;6e arrdt&quot;, &quot;7e arrdt&quot;, &quot;4e arrdt&quot;,&quot;13e arrdt&quot;,&quot;20e arrdt&quot;,&quot;19e arrdt&quot;))) %&gt;% ggplot() + aes(x=annee, y=med_prixm2, color=nom_arrdt) + geom_line(aes(group=nom_arrdt), linewidth=1) + scale_y_continuous(limits=c(6000,16000), breaks = seq(6000,16000,1000)) + labs(title=&quot;Evolution du prix médian au m2 des appartements vendus à Paris, dans les 3 arrondissements \\nayant les prix les plus élevés et les 3 arrondissements ayant les prix les moins élevés&quot;, x = &quot; &quot;, y = &quot; &quot;, color=&quot;Arrondissement&quot;) + theme(plot.title = element_text(size=10.3), legend.title = element_text(size=9), plot.caption = element_text(hjust=0)) ggplotly(g_evo_pls, tooltip = c(&quot;med_prixm2&quot;)) %&gt;% layout(margin = list(l = 50, r = 50, b = 80, t = 50), annotations = list(text = &quot;Source : Base &#39;demande de valeurs foncières&#39;, 2019-2022. \\nCalculs : Camille Signoretto. \\nNote : l&#39;axe des ordonnées ne commence qu&#39;à 6000€&quot;, showarrow = F, x = 0, y = -0.2, xref=&#39;paper&#39;, yref=&#39;paper&#39;, xanchor=&#39;left&#39;, yanchor=&#39;auto&#39;, xshift=0, yshift=0, font=list(size=10.3), align=&quot;left&quot;)) Pour tous les arrondissements, les prix médians au m2 sont à la hausse entre 2019 et 2020, mais connaissent ensuite parfois des stagnations, alors que d’autres continuent à augmenter (surtout pour le 6ème arronddisement), entre 2021 et 2022, deux arrondissements se démarquent - les 4ème et 7ème - car le prix médian continue à augmenter contrairement aux autres pour lesquels il diminue ou stagne. 8.2.4 Top 5 du prix au m2 des ventes d’appartements selon les arrondissements Enfin, construisez un graphique en bâtons indiquant les seuls 5 premiers arrondissements ayant les prix moyens au m2 des ventes d’appartements les plus élevés, puis les prix médians, et les mettre côte à côte. p5 &lt;- dvf_Paris_1 %&gt;% filter(!is.na(code_postal)) %&gt;% group_by(nom_arrdt) %&gt;% summarise(moy_prixm2 = round(mean(px_m2))) %&gt;% arrange(desc(moy_prixm2)) %&gt;% slice(1:5) %&gt;% ggplot() + aes(x = moy_prixm2, y = fct_reorder(nom_arrdt, moy_prixm2)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;darkgoldenrod1&quot;) + geom_text(aes(label=moy_prixm2), position = position_stack(vjust=0.5), size=2.8) + labs(title=&quot;Prix moyens&quot;, x = &quot;&quot;, y = &quot; &quot;) + theme_classic() + theme(legend.position = &quot;none&quot;, plot.title=element_text(size=9), axis.text.y = element_text(size=8), axis.text.x = element_text(size=8), axis.title.x = element_text(size=8)) p6 &lt;- dvf_Paris_1 %&gt;% filter(!is.na(code_postal)) %&gt;% group_by(nom_arrdt) %&gt;% summarise(moy_prixm2 = round(mean(px_m2))) %&gt;% arrange(desc(moy_prixm2)) %&gt;% slice(1:5) %&gt;% ggplot() + aes(x = moy_prixm2, y = fct_reorder(nom_arrdt, moy_prixm2)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;coral1&quot;) + geom_text(aes(label=moy_prixm2), position = position_stack(vjust=0.5), size=2.8) + labs(title=&quot;Prix médians&quot;, x = &quot;&quot;, y = &quot; &quot;) + theme_classic() + theme(legend.position = &quot;none&quot;, plot.title=element_text(size=9), axis.text.y = element_text(size=8), axis.text.x = element_text(size=8), axis.title.x = element_text(size=8)) (p5 + p6) + plot_annotation(title = &quot;Top 5 des arrondissements ayant les prix au m2 des ventes d&#39;appartements les plus élevés&quot;, caption = &quot;Source : Base &#39;demande de valeurs foncières&#39;, 2019-2022. \\nCalculs : Camille Signoretto.&quot;, theme = theme(plot.title = element_text(size = 12))) &amp; theme(plot.caption = element_text(hjust = 0)) On retrouve les mêmes résultats. 8.2.5 À vous de “jouer” ! Bien sûr, vous pouvez créer des fonctions sur ces graphiques ; puis “jouez” avec d’autres variables, notamment la surface et le nombre de pièces ; ou encore construire des cartes sur le niveau commune ; utiliser d’autres types de graphiques ; etc. ; etc. "],["09-Intro-a-Shiny-theorique.html", "Section 9 Les applications interactives avec Shiny App 9.1 La structure générale d’une application Shiny 9.2 La réactivité 9.3 Un exemple avec le code du script par défaut", " Section 9 Les applications interactives avec Shiny App Comme indiqué sur la page officielle de Shiny-RStudio ici, Shiny est un package R qui permet de créer des applications ou des pages web de visualisations interactives de données, directement à partir de R, autremet dit sans connaître nécessairement le langage HTML, Javascript, etc., et donc aussi en pouvant utiliser toutes les fonctions disponibles sous R. En réalité, l’interface utilisateur de l’application Shiny est bien du langage HTML, mais Shiny donne des outils faciles pour l’écrire sans avoir à connaître le HTML. Il nous faut d’abord installer le package Shiny, puis le charger : #install.packages(&quot;shiny&quot;) library(shiny) Des exemples d’application Shiny sont données sur la page officielle dans la galerie ; ou on peut aussi en lancer une directement dans R, avec par exemple le code suivant : # Voici la liste des exemples que vous pouvez spécifier dans la fonction # suivante : &quot;01_hello&quot;, &quot;02_text&quot;, &quot;03_reactivity&quot;, &quot;04_mpg&quot;, # &quot;05_sliders&quot;, &quot;06_tabsets&quot;, &quot;07_widgets&quot;, &quot;08_html&quot;, &quot;09_upload&quot;, # &quot;10_download&quot;, &quot;11_timer&quot; runExample(&quot;01_hello&quot;) Un autre exemple d’application finale qui comprend un aspect territorial donc avec de jolis cartes, et qui s’appuie sur les données du Recensement de la population (rassemblées par l’Insee sur la période 1968-2019 et qui forme la base Saphir), est disponible ici . Enfin, cette introduction s’appuie sur d’autres ressources externes, pour n’en citer que quelques uns : - un bon tutoriel ici ; - une introduction claire là. Et vous trouverez sur les 2 liens suivants deux ouvrages en ligne, pour compléter et aller plus loin : the Mastering Shiny ; et the Interactive web-based data visualization with R, plotly, and shiny. 9.1 La structure générale d’une application Shiny L’application est divisée en 2 sections : l’interface utilisateur (ui) et une fonction serveur (server). L’intérêt de Shiny est sa réactivité : quand l’utilisateur change un paramètre, tout ce qui dépend de ce paramètre est automatiquement actualisé sur la page. On dit que c’est une application “server-based”, dans la mesure où la construction des graphiques et/ou tableaux affichés (ou tout autre objet) se font sur le serveur, autrement dit sur le RStudio de votre ordinateur. Ainsi, comme on peut le voir sur les exemples cités au-dessus, la structure du code sera toujours la suivante : library(shiny) # Fonction &quot;ui&quot; ui &lt;- fluidPage( ) # Fonction &quot;server&quot; server &lt;- function(input, output) { } # Fonction qui crée l&#39;application Shiny en reprenant les 2 fonctions # principales. A noter que comme elles ont le même nom, souvent on ne # précisera pas de nouveau les arguments &quot;ui = &quot; et &quot;server = &quot; shinyApp(ui = ui, server = server) 9.1.1 La partie “UI” L’UI ou “interface utilisateur” utilise par défaut la fonction fluidPage() qui permet de créer la mise en page de l’application et qui répondra automatiquement aux changements effectués sur le navigateur par l’utilisateur. Cette fonction fluidPage() va contenir des indications comme le titre (avec titlePanel()), éventuellement un sous-titre, etc., ainsi que deux fonctions sidebarLayout() et mainPanel(). Le première comprend la fonction sidebarPanel() qui contient le ou les “widgets” à partir duquel ou desquels les utilisateurs sélectionneront des valeurs – par défaut est indiqué un sliderInput(). La seconde contient la sortie voulue, c’est-à-dire un graphique, un tableau, etc., avec par défaut la fonction plotOutput(), mais elle peut en contenir d’autres… Les graphiques ou tableaux de ces fonctions ...Ouput() sont ensuite précisées (et construits) dans la partie “Server” de l’application Shiny. #library(shiny) # Fonction &quot;ui&quot; ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Titre à définir&quot;), # Mise en page de la barre latérale avec les définitions des # entrées et des sorties sidebarLayout( # Panneau latéral pour les entrées sidebarPanel( # Entrée : wigdet choisi, par défaut &quot;sliderInput()&quot; sliderInput( ) ), # Panneau principal pour l&#39;affichage des sorties mainPanel( # Sortie : graphique, tableau, etc. plotOutput(&quot;nom_du_graphe&quot;) ) ) ) # Fonction &quot;server&quot; server &lt;- function(input, output) { } # Fonction qui crée l&#39;application Shiny shinyApp(ui = ui, server = server) La liste des widgets est reproduite ci-dessous avec un tableau et une image récapitulative (disponible directement ici) ; à part les arguments communs inputID() et label(), les autres arguments diffèrent selon le widget, il est donc essentiel d’y faire un tour avant d’en utiliser un si l’on ne le connaît pas a priori. Tableau : Fonctions Shiny et widgets associés Fonction Widget sliderInput Barre de défilement actionButton Bouton d’action checkboxGroupInput Groupe de cases à cocher checkboxInput Case unique à cocher dateInput calendrier pour sélectionner une ou des dates dateRangeInput Paire de calendriers pour sélectionner une plage de dates numericInput Champ pour saisir des chiffres radioButtons Série de boutons radio selectInput Boîte avec des choix à sélectionner submitButton Bouton de validation fileInput Commande pour télécharger un fichier à partir d’un chemin textInput Champ pour saisir du texte helpText Texte d’aide qui peut être ajouté à un formulaire de saisie Widgets de l’application Shiny D’autres interfaces utilisateur existent. Par exemple, avec le package bslib, on peut utiliser la fonction page_sidebar() à la place de fluidPage(), comme ceci : #library(shiny) library(bslib) # Fonction &quot;ui&quot; ui &lt;- page_sidebar( title = &quot;Titre à définir&quot;, sidebar = sidebar(&quot;Barre latéral&quot;), &quot;Contenu principal&quot;, mainPanel( # Sortie : graphique, tableau, etc. plotOutput(&quot;nom_du_graphe&quot;) ) ) # Fonction &quot;server&quot; server &lt;- function(input, output) { } # Fonction qui crée l&#39;application Shiny shinyApp(ui = ui, server = server) Ou encore la fonction navbarPage() pour permettre plusieurs onglets de navigation sur la même page web (que l’on créera avec la fonction tabPanel() à l’intérieur de laquelle on retrouvera les fonctions sidebarPanel() et mainPanel()) : # Fonction &quot;server&quot; ui &lt;- navbarPage( title=&quot;Titre à définir&quot;, tabPanel(title = &quot;Graphique&quot;, fluidPage( sidebarLayout( sidebarPanel( # sliderInput( # ) ), mainPanel( plotOutput(&quot;nom_du_graphe&quot;) ) ) ) ), tabPanel(&quot;Résumé des variables&quot;), tabPanel(&quot;Tableau&quot;), ) # Fonction &quot;server&quot; server &lt;- function(input, output) { } # Fonction qui crée l&#39;application Shiny shinyApp(ui = ui, server = server) 9.1.2 La partie “Server” C’est la fonction Server qui contient le code principal faisant tourner l’application web. Elle est définie par la fonction function(input, output){ }. À chaque fonction ...Ouput() dans l’ui correspond une fonction render...() dans la partie Server. Par exemple, si dans la partie ui, on a définit un histogramme comme ceci dans la fonction : plotOuput(\"distPlot\"), alors dans la partie server, on associera la fonction renderPlot() à output$distPlot. Les fonctions render...() sont celles qui contiennent en effet le code créant, l’histogramme ici, ou tout autre graphique ou tableau, l’ensemble de l’expression à l’intérieur de cette fonction sera contenu dans des accolades {}. #library(shiny) # Fonction &quot;ui&quot; ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Titre à définir&quot;), # Mise en page de la barre latérale avec les définitions des # entrées et des sorties sidebarLayout( # Panneau latéral pour les entrées sidebarPanel( # Entrée : wigdet choisi, par défaut &quot;sliderInput()&quot; sliderInput( ) ), # Panneau principal pour l&#39;affichage des sorties mainPanel( # Sortie : graphique, tableau, etc. plotOutput(&quot;nom_du_graphe&quot;) ) ) ) # Fonction &quot;server&quot; server &lt;- function(input, output) { # Reprend la sortie mentionnée plus haut (ici &quot;nom_du_graphe&quot;) output$nom_du_graphe &lt;- renderPlot({ # code de création du graphique, qui sera réactive selon les # valeurs données en entrées (cf. fonction &quot;fluidPage()&quot;) }) } # Fonction qui crée l&#39;application Shiny shinyApp(ui = ui, server = server) Voici les différentes fonctions ...Ouput() créant un objet de sortie : Fonction de sortie Type d’objet créé dataTableOutput Table de données imageOutput Image plotOutput Graphique tableOutput Table textOutput Texte uiOutput HTML brut htmlOutput HTML brut verbatimTextOutput Texte Et les fonctions render...() associées : Fonction de sortie Type d’objet créé renderDataTable Table de données renderImage Image (enregistré comme un lien vers un fichier source) renderPlot Graphique renderTable Table de données, matrices, ou autres structures de type tableau renderText Texte sous forme de chaînes de caractères renderUI objet de balise Shiny ou HTML renderPrint Toute sortie imprimée 9.2 La réactivité Comme dit précédemment, la réactivité est au centre du fonctionnement d’une application Shiny. Plusieurs types de réactivité peut être distingués : un premier type de réactivité, le plus simple, à travers les interactions entre les fonctions ui() et server() : comme expliqué au-dessus, cela passe par les “input” définis dans la partie ui et les “output” créés dans la partie server ; plus précisément, si on a définit un widget permettant par exemple de choisir une année donnée et qu’on l’a appelé annee (avec l’argument id=\" \"), alors dans la ou les fonctions render...() de la partie server, il faudra renvoyer à cette variable par l’indication input$annee. De manière générale, il faudra accoler le nom donné à un input x de cette façon dans le server : input$x. Cela peut être résumé par le schéma suivant, emprunté à l’une des sources citées en introduction : Reactivité UI et Server Source : https://laderast.github.io/gradual_shiny/introduction.html un deuxième type de réactivité à travers la base de données elle-même, c’est-à-dire qui crée un objet réactif (qui sera à la fois une entrée réactive et une sortie réactive) : il faut alors utiliser, par exemple, la fonction reactive({}) (ou son corrolaire eventReactive()) en l’appliquant à la base de données initiale et en renvoyant ainsi une nouvelle base, qui sera elle-même une fonction. On peut par exemple appliquer un filtre à notre base de données selon l’année : au lieu alors de préciser input$annee dans la fonction render...() comme mentionné dans le premier type de réactivité, on va en réalité créer une nouvelle base comme ceci : data_reactive &lt;- reactive({ data %&gt;% filter(annee &gt; input$annee)) }) ; puis l’appeler ainsi pour créer le graphique : output$nom_du_graphe &lt;- renderPlot({ data_reactive() }), attention vous noterez l’utilisation des parenthèses après le nouveau nom de la table. De même, cela peut être résumé par le schéma suivant tiré de la même source : Reactivité base de donneées Source : https://laderast.github.io/gradual_shiny/app-2-reactives.html un troisième type de réactivité qui crée un contexte réactif, à travers notamment la fonction observe({}) (ou son corrolaire observeEvent()) : cette fonction sera utilisée losque vous souhaitez faire une opération qui dépend de plusieurs autres variables réactives, en particulier si vous souhaitez changer un input qui est dépendant d’un autre input, mais sans créer nécessairement d’output. Cela peut être utile si le choix d’une variable - les départements d’une région par exemple - est conditionnée au choix antérieur de la région en question : dans ce cas, l’utilisateur qui choisira une région dans un premier widget ne verra s’afficher que les départements de cette région dans un second widget et non tous les départements disponibles dans la base de données. Il y a bien d’autres fonctions de réactivité dans Shiny : eventReactive(), observeEvent(), reactiveValues(), isolate(), req(), mais qu’on ne présentera pas forcément en détails dans ce cours mais que vous pourrez utiliser dans votre application finale. 9.3 Un exemple avec le code du script par défaut Voyons ensemble un premier exemple : dans RStudio, ouvrez un nouveau fichier “Shiny Web App…” que vous intitulez comme vous le souhaitez (attention, pas d’espace permis entre deux mots par exemple), vous laissez l’option “Single File” et vous l’enregistrez de préférence dans votre projet. Un nouveau scrip s’ouvre avec par défaut un code minimal déjà écrit : on retrouve la structure du code présentée juste au-dessus, et à l’intérieur de l’UI et du Server quelques codes pour avoir un titre, un widget sous forme de “slider” et un graphique qui sera un histogramme d’après la fonction écrit dans la partie Server. Faisons tourner l’application avec le bouton en haut à droite “Run App” pour voir ce que cela donne ! On voit bien les différents éléments correspondants au code écrit dans le script R et on voit bien également que l’application est interactive puisque si l’on modifie le nombre de classes dans la barre slider, le graphique est modifié alors simultanément ! "],["10-Intro-a-Shiny-exemples.html", "Section 10 La création d’une application Shiny “pas à pas” avec l’une de nos bases de données 10.1 Application vide 10.2 Ajout d’un titre et d’un widget 10.3 Ajout d’un graphique 10.4 Modification du graphique : filtrer selon une variable 10.5 Modification du graphique : selon une variable au choix parmi deux Section 11 Applications plus poussées sur Shiny 11.1 Application avec un tableau et un graphique sur une autre base de données 11.2 Introduction d’une réactivité appliquée à la table de données 11.3 Introduction d’une réactivité sur les inputs (contexte réactif)", " Section 10 La création d’une application Shiny “pas à pas” avec l’une de nos bases de données On va utiliser la base du RP sur laquelle nous travaillons depuis le début, mais en créant des tableaux de contingence à partir des fonctions sauvegardées dans la section précédente. 10.1 Application vide Faisons tourner une application vide et ajoutons au fur et à mesure les éléments qui permettrons de construire une vraie application : library(shiny) ui &lt;- fluidPage( ) server &lt;- function(input, output) { } shinyApp(ui = ui, server = server) 10.2 Ajout d’un titre et d’un widget Ajoutons un titre et un widget, par exemple une barre “slider” : #library(shiny) # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne&quot;), # Définition du Widget - ici un slider en vue de construire un histogramme sidebarLayout( sidebarPanel( sliderInput(inputId = &quot;Classes&quot;, label = &quot;Nombres de classes : &quot;, min = 1, max = 50, value = 25) ), mainPanel( plotOutput(&quot;histPlot&quot;) ) ) ) server &lt;- function(input, output) { } shinyApp(ui = ui, server = server) 10.3 Ajout d’un graphique Ajoutons un graphique ; il faut pour cela charger la base de données sur laquelle nous allons travailler ; pour l’exemple ici, nous allons créer un tableau de contingence à partir des fonctions créées précédemment (qu’on appelle donc avant) et donnant le nombre de propriétaires par commune de l’Île-de-France, en considérant les arrondissements de Paris comme des communes : # appel fonctions enregistrées source(&quot;fonctions/fonctions.R&quot;) # création de la table de données tab_proprio_com &lt;- RP_final %&gt;% filter(STOCD == &quot;10&quot;) %&gt;% somme(var_gpe=COM, nom_var=STOCD) %&gt;% rename(nb_proprio = &#39;10&#39;) %&gt;% filter(COM!=&quot;ZZZZZ&quot;) #library(shiny) # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne&quot;), # Définition du Widget - ici un slider en vue de construire un histogramme sidebarLayout( sidebarPanel( sliderInput(inputId = &quot;classes&quot;, label = &quot;Nombres de classes&quot;, min = 1, max = 50, value = 25) ), # Graphe montré à l&#39;utilisateur mainPanel( plotOutput(&quot;histPlot&quot;) ) ) ) server &lt;- function(input, output) { output$histPlot &lt;- renderPlot({ tab_proprio_com %&gt;% ggplot() + aes(x=nb_proprio) + geom_histogram(bins=25) }) } shinyApp(ui = ui, server = server) On a bien maintenant le graphique qui s’affiche mais lorsqu’on change le nombre de classes dans la barre slider, rien ne se passe… C’est normal, nous n’avons pas encore introduit de réactivité dans l’application. Pour cela, il va falloir modifier le code dans la fonction server et ainsi mettre en lien des informations indiquées dans la fonction UI avec les arguments utilisés dans le graphique développé dans la fonction server. Pour l’instant, on veut pouvoir modifier le nombre de classes, l’argument pour cela dans la fonction geom_histogram() dans le ggplot() est bins= ; on a indiqué ‘50’ jusqu’ici ; maintenant il faut lui indiquer le nombre que l’utilisateur va lui-même indiquer dans la barre slider ; cela se fait avec l’argument input$..., les “…” devant être remplacés par le nom que l’on a donné à l’inputId dans le sliderInput(), donc ici “classes”. # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne&quot;), # Définition du Widget - ici un slider en vue de construire un histogramme sidebarLayout( sidebarPanel( sliderInput(inputId = &quot;classes&quot;, label = &quot;Nombres de classes&quot;, min = 1, max = 50, value = 25) ), # Graphe montré à l&#39;utilisateur mainPanel( plotOutput(&quot;histPlot&quot;) ) ) ) server &lt;- function(input, output) { output$histPlot &lt;- renderPlot({ tab_proprio_com %&gt;% ggplot() + aes(x=nb_proprio) + geom_histogram(bins=input$classes) }) } shinyApp(ui = ui, server = server) Ça y est, maintenant lorsqu’on modifie le curseur dans la barre slider, le graphique change ! 10.4 Modification du graphique : filtrer selon une variable Essayons ensuite d’ajouter un filtre sur le département pour n’avoir que la distribution du nombre de propriétaires pour un département donné. Comme on n’a pas de variable de département, il faut la créer, ce que l’on peut faire assez facilement à partir des deux premiers chiffres de la commune, et ensuite il suffit d’ajouter un filtre sur cette nouvelle variable créée. De même, on peut procéder par étapes : présentons d’abord le graphique pour le seul département de l’Île-de-France (75). # Création de la variable et donc remplacement de la table de données tab_proprio_com &lt;- tab_proprio_com %&gt;% mutate(DEPT=as.factor(substr(COM, 1,2))) # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne&quot;), # Définition du Widget - ici un slider en vue de construire un histogramme sidebarLayout( sidebarPanel( sliderInput(inputId = &quot;classes&quot;, label = &quot;Nombres de classes&quot;, min = 1, max = 50, value = 25) ), # Graphe montré à l&#39;utilisateur mainPanel( plotOutput(&quot;histPlot&quot;) ) ) ) server &lt;- function(input, output) { output$histPlot &lt;- renderPlot({ tab_proprio_com %&gt;% filter(DEPT == &quot;75&quot;) %&gt;% ggplot() + aes(x=nb_proprio) + geom_histogram(bins=input$classes) }) } shinyApp(ui = ui, server = server) Ensuite, donnons la possibilité à l’utilisateur de choisir le département qu’il veut : il faut pour cela ajouter un widget dans la fonction UI ; comme on ne veut laisser qu’un choix de département à l’utilisateur, on peut utiliser un “Radio buttons” ; on regarde alors quels sont les arguments de la fonction radioButtons(), on voit qu’il faut indiquer les choix possibles donc ici la liste des départements dans choices = et indiquer une valeur par défaut dans selected = ; pour cela, on peut indiquer la variable correspondante choices = tab_proprio$DEPT, mais attention si on laisse comme ceci, on va avoir une répétition de noms des départements comme lorsqu’on ouvre la table, ce qu’on veut c’est uniquement les niveaux… deux possibilités alors : soit créer avant l’appel de la fonction UI une variable avec simplement les niveaux de cette variable ; soit passer par la fonction unique() dans l’argument donné. # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne&quot;), # Définition du Widget - ici un slider en vue de construire un histogramme sidebarLayout( sidebarPanel( sliderInput(inputId = &quot;classes&quot;, label = &quot;Nombres de classes&quot;, min = 1, max = 50, value = 25), radioButtons(inputId = &quot;dept&quot;, label = &quot;Choix du département&quot;, choices = levels(tab_proprio_com$DEPT), #ou indiquer unique(tab_proprio_com$DEPT) selected = &quot;75&quot;), ), # Graphe montré à l&#39;utilisateur mainPanel( plotOutput(&quot;histPlot&quot;) ) ) ) server &lt;- function(input, output) { output$histPlot &lt;- renderPlot({ tab_proprio_com %&gt;% filter(DEPT == &quot;75&quot;) %&gt;% ggplot() + aes(x=nb_proprio) + geom_histogram(bins=input$classes) }) } shinyApp(ui = ui, server = server) Enfin, là encore, il faut introduire la réactivité et “connecter” la partie UI et la partie server, en remplaçant le nom du département dans le filter(dept == ) par le nom de l’inputId indiqué dans notre “radioButtons” : # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne&quot;), # Définition du Widget - ici un slider en vue de construire un histogramme sidebarLayout( sidebarPanel( sliderInput(inputId = &quot;classes&quot;, label = &quot;Nombres de classes&quot;, min = 1, max = 50, value = 25), radioButtons(inputId = &quot;dept&quot;, label = &quot;Choix du département&quot;, choices = levels(tab_proprio_com$DEPT), #ou indiquer unique(tab_proprio_com$DEPT) selected = &quot;75&quot;), ), # Graphe montré à l&#39;utilisateur mainPanel( plotOutput(&quot;histPlot&quot;) ) ) ) server &lt;- function(input, output) { output$histPlot &lt;- renderPlot({ tab_proprio_com %&gt;% filter(DEPT == input$dept) %&gt;% ggplot() + aes(x=nb_proprio) + geom_histogram(bins=input$classes) }) } shinyApp(ui = ui, server = server) On peut voir que le nombre de classes maximum de 50 n’est absolument pas pertinent pour certains départements qui ont peu de communes, c’est quelque chose qui pourra être modifiée bien sûr ultérieurement. 10.5 Modification du graphique : selon une variable au choix parmi deux On peut maintenant vouloir montrer un graphique (toujours le même histogramme) selon au choix deux variables : soit le nombre de propriétaires, soit le nombre de locataires. Il faut donc créer cette dernière variable de la même façon que précédemment pour les propriétaires, et l’ajouter au tableau précédent (qu’on renommera puisqu’il ne concerne plus les seuls propriétaires…). tab_locataires_com &lt;- RP_final %&gt;% filter(STOCD %in% c(&quot;21&quot;,&quot;22&quot;,&quot;23&quot;)) %&gt;% mutate(STOCD=case_when(STOCD %in% c(&quot;21&quot;,&quot;22&quot;,&quot;23&quot;) ~ &quot;nb_locataires&quot;)) %&gt;% somme(var_gpe=COM, nom_var=STOCD) %&gt;% filter(COM!=&quot;ZZZZZ&quot;) tab_st_occ &lt;- tab_proprio_com %&gt;% left_join(tab_locataires_com, by=join_by(&quot;COM&quot;)) # pour supprimer les tables intermédiaires rm(tab_locataires_com, tab_proprio_com) Procédons comme précédemment : créons un nouveau widget avec par exemple selectInput(), dont l’inputID sera “variable” et l’argument choices = donne les deux variables choisies ; pour cela, on peut utiliser une fonction list() et indiquer le nom des deux variables, soient nb_proprio et nb_locataires. Et ensuite, dans la fonction server, remplaçons x=nb_proprio par x=input$variable et voyons si cela marche ! # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Statut d&#39;occupation des logements agrégé au niveau communal, selon le département&quot;), # Définition du Widget - ici un slider en vue de construire un histogramme sidebarLayout( sidebarPanel( sliderInput(inputId = &quot;classes&quot;, label = &quot;Nombres de classes&quot;, min = 1, max = 50, value = 25), radioButtons(inputId = &quot;dept&quot;, label = &quot;Choix du département&quot;, choices = levels(tab_st_occ$DEPT), selected = &quot;75&quot;), selectInput(inputId = &quot;variable&quot;, label = &quot;Choix de la variable&quot;, choices = list(&quot;nb_proprio&quot;, &quot;nb_locataires&quot;), selected = &quot;nb_proprio&quot;), ), # Graphe montré à l&#39;utilisateur mainPanel( plotOutput(&quot;histPlot&quot;) ) ) ) server &lt;- function(input, output) { output$histPlot &lt;- renderPlot({ tab_st_occ %&gt;% filter(DEPT == input$dept) %&gt;% ggplot() + aes(x=input$variable) + geom_histogram(bins=input$classes) }) } shinyApp(ui = ui, server = server) Et non cela ne fonctionne pas. En réalité, comme nous avons utilisé dans choices = une fonction list() qui fait appel à des variables de type caractère, la fonction ggplot() + aes(x = ) ne comprend pas que la variable appelée est bien une variable numérique (son contenu), elle croît en quelque sorte que c’est une variable caractère. Il faut donc dire à la fonction ggplot() ici que le nom de la variable est de type “string” mais qu’elle comporte bien des valeurs numériques donc compatible avec un histogramme : pour cela, au lieu de ggplot() + aes(x = ), il faut utiliser ggplot() + aes_string(x = ). Réessayons : # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Statut d&#39;occupation des logements agrégé au niveau communal, selon le département&quot;), # Définition du Widget - ici un slider en vue de construire un histogramme sidebarLayout( sidebarPanel( sliderInput(inputId = &quot;classes&quot;, label = &quot;Nombres de classes&quot;, min = 1, max = 50, value = 25), radioButtons(inputId = &quot;dept&quot;, label = &quot;Choix du département&quot;, choices = unique(tab_st_occ$DEPT), selected = &quot;75&quot;), selectInput(inputId = &quot;variable&quot;, label = &quot;Choix de la variable&quot;, choices = list(&quot;nb_proprio&quot;, &quot;nb_locataires&quot;), selected = &quot;nb_proprio&quot;), ), # Graphe montré à l&#39;utilisateur mainPanel( plotOutput(&quot;histPlot&quot;) ) ) ) server &lt;- function(input, output) { output$histPlot &lt;- renderPlot({ tab_st_occ %&gt;% filter(DEPT == input$dept) %&gt;% ggplot() + aes_string(x=input$variable) + geom_histogram(bins=input$classes) }) } shinyApp(ui = ui, server = server) Enfin, on peut ajouter en-dessous de l’histogramme un autre graphique, en l’occurence une boîte à moustache, et introduire une réactivité sur la base de données, ce qui permet un gain d’efficacité (en particulier en cas de base de données volumineuse) et ici d’éviter de réécrire deux fois le filtre dans les deux fonctions créant les deux graphiques : # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Statut d&#39;occupation des logements au niveau communal, selon le département&quot;), # Définition du Widget - ici un slider en vue de construire un histogramme sidebarLayout( sidebarPanel( sliderInput(inputId = &quot;classes&quot;, label = &quot;Nombres de classes pour l&#39;histogramme&quot;, min = 1, max = 50, value = 25), radioButtons(inputId = &quot;dept&quot;, label = &quot;Choix du département&quot;, choices = unique(tab_st_occ$DEPT), #ou indiquer &#39;nom_dept&#39; selected = &quot;75&quot;), selectInput(inputId = &quot;variable&quot;, label = &quot;Choix de la variable&quot;, choices = list(&quot;nb_proprio&quot;, &quot;nb_locataires&quot;), selected = &quot;nb_proprio&quot;), ), # Graphe montré à l&#39;utilisateur mainPanel( plotOutput(&quot;histPlot&quot;), plotOutput(&quot;boxPlot&quot;) ) ) ) server &lt;- function(input, output) { # Base réactive tab_st_occ_react &lt;- reactive({ tab_st_occ %&gt;% filter(DEPT == input$dept) }) output$histPlot &lt;- renderPlot({ tab_st_occ_react() %&gt;% ggplot() + aes_string(x=input$variable) + geom_histogram(bins=input$classes) }) output$boxPlot &lt;- renderPlot({ tab_st_occ_react() %&gt;% ggplot() + aes_string(y = input$variable) + geom_boxplot() + coord_flip() + scale_y_continuous(limits=c(0,quantile(tab_st_occ_react()[[input$variable]], 0.75)*2)) + labs(caption=&quot;Rq : les valeurs supérieures à 2 fois le Q3 de la distribution ne sont pas affichées sur le graphique&quot;, x=&quot;&quot;, y=&quot;&quot;) + theme(plot.caption = element_text(hjust=0, size=11.5)) }) } shinyApp(ui = ui, server = server) Section 11 Applications plus poussées sur Shiny 11.1 Application avec un tableau et un graphique sur une autre base de données En repartant de la base DVF des ventes d’appartements à Paris entre 2019 et 2022, on va créer une autre application en mettant en haut un tableau général récapitulant pour Paris et sur la période d’ensemble les informations suivantes : le prix moyen et médian au m2, le nombre moyen de pièces et le nombre de ventes ; puis en-dessous de ce tableau, on va ajouter un graphique (barplot) qui va représenter le “top 5” du prix médian au m2 des ventes d’appartements selon le nombre de pièces et selon l’arrondissement. Pour avoir des chiffres plus près de la réalité par rapport aux graphiques réalisées dans les sections précédentes sur cette base de données, on ne va prendre que les observations qui correspondent à une vente unique (id_mutation et id_parcelle différente pour chaque observation/ligne) ; on va utiliser pour cela la fonction add_count(). Ainsi, le premier tableau ne sera pas à ce stade réactif, alors que le graphique le sera. Il y aura par conséquent deux widgets, l’un pour choisir l’année considérée et l’autre pour choisir le nombre de pièces des logements. Pour le tableau, vous pouvez utiliser le package gt() et la fonction gt_output() pour l’appel du tableau dans la partie UI associée à la fonction render_gt() dans la partie server. Cela doit vous donner ceci : # Chargement des librairies library(shiny) library(tidyverse) library(gt) library(RColorBrewer) library(forcats) # Chargement du fichier dvf_Paris_1 &lt;- readRDS(&quot;data/dvf_Paris_1.Rdata&quot;) # Création de la variable catégories de nombre de pièces et mise en factor de la variable du nom d&#39;arrondissement dvf_Paris_1 &lt;- dvf_Paris_1 %&gt;% filter(nom_arrdt != &quot;NA&quot;) %&gt;% mutate(nbpieces_cat=as.factor(case_when(nombre_pieces_principales==1 ~ &#39;Une pièce&#39;, nombre_pieces_principales==2 ~ &#39;Deux pièces&#39;, nombre_pieces_principales&gt;=3 ~ &#39;Trois pièces ou plus&#39;)), nbpieces_cat=factor(nbpieces_cat, levels=c(&#39;Une pièce&#39;, &#39;Deux pièces&#39;, &#39;Trois pièces ou plus&#39;)), annee=as.factor(annee)) %&gt;% add_count(id_mutation, id_parcelle, annee, surface_reelle_bati) # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Caractéristiques des ventes d&#39;appartements dans Paris sur la période 2019-2022&quot;), br(), # Définition du Widget sidebarLayout( sidebarPanel( selectInput(inputId = &quot;annee&quot;, label = &quot;Choix de l&#39;année de vente&quot;, choices = list(&quot;2019&quot;, &quot;2020&quot;, &quot;2021&quot;,&quot;2022&quot;), selected = &quot;2019&quot;), radioButtons(inputId = &quot;nb_pieces&quot;, label = &quot;Choix du nombre de pièces&quot;, choices = levels(dvf_Paris_1$nbpieces_cat), selected = &quot;Deux pièces&quot;) ), # Tableau et graphe montré à l&#39;utilisateur mainPanel( gt_output(&quot;tab&quot;), br(), br(), plotOutput(&quot;barplot&quot;) ) ) ) server &lt;- function(input, output) { output$tab &lt;- render_gt({ dvf_Paris_1 %&gt;% filter(n==1) %&gt;% summarise(&quot;Nombre de ventes d&#39;appartements&quot; = sum(nombre_lots), &quot;Prix moyen au m2 des appartements, en €&quot; = round(mean(px_m2)), &quot;Prix médian au m2 des appartements, en €&quot; = round(median(px_m2)), &quot;Nombre moyen de pièces&quot; = round(mean(nombre_pieces_principales))) %&gt;% gt() %&gt;% fmt_number(columns= 1:3, sep_mark = &quot; &quot;, decimals = 0) %&gt;% tab_header(title=md(&#39;**Principaux indicateurs sur la période 2019-2022**&#39;)) }) output$barplot &lt;- renderPlot({ dvf_Paris_1 %&gt;% filter(annee == input$annee &amp; nbpieces_cat==input$nb_pieces &amp; n==1) %&gt;% group_by(nom_arrdt) %&gt;% summarise(med_prixm2 = round(median(px_m2))) %&gt;% arrange(desc(med_prixm2)) %&gt;% slice(1:5) %&gt;% ggplot() + aes(x = med_prixm2, y = fct_reorder(nom_arrdt, med_prixm2)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;darkgoldenrod1&quot;) + geom_text(aes(label=med_prixm2), position = position_stack(vjust=0.5), size=3.8) + labs(title = paste(&quot;Top 5 des arrondissements ayant les prix médians au m2 des ventes \\nd&#39;appartements&quot;, ifelse(input$nb_pieces==&quot;Une pièce&quot;, &quot;d&#39;une pièce&quot;, ifelse(input$nb_pieces==&quot;Deux pièces&quot;, &quot;de deux pièces&quot;, ifelse(input$nb_pieces==&quot;Trois pièces ou plus&quot;, &quot;de trois pièces ou plus&quot;))), &quot;les plus élevés en&quot;, input$annee), x=&quot; &quot;, y=&quot; &quot;, caption = &quot;Source : Base &#39;demande de valeurs foncières&#39;, 2019-2022.&quot;) + theme_classic() + theme(plot.title = element_text(size=17), plot.caption = element_text(hjust = 0, size=12), axis.text.y = element_text(size=12.5), axis.text.x = element_text(size=12.5)) }) } shinyApp(ui = ui, server = server) Par rapport aux exemples précédents déjà réalisés sur Shiny, nous n’avons pas beaucoup ajouté de choses nouvelles : un peu de langage html (br()) pour insérer des espaces entre le tableau et le graphique, ou le titre général et le reste des éléments de l’application ; puis une fonction de condition à l’intérieur du labs() de Ggplot et avec la fonction paste() pour, d’une part, que le titre change selon le nombre de pièces choisi par l’utilisateur (plusieurs fonctions ifelse()), et, d’autre part, que le titre change selon l’année choisie). On va maintenant rendre le tableau réactif selon l’année choisie. # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Caractéristiques des ventes d&#39;appartements dans Paris sur la période 2019-2022&quot;), br(), # Définition du Widget sidebarLayout( sidebarPanel( selectInput(inputId = &quot;annee&quot;, label = &quot;Choix de l&#39;année de vente pour le tableau et le graphique&quot;, choices = list(&quot;2019&quot;, &quot;2020&quot;, &quot;2021&quot;,&quot;2022&quot;), selected = &quot;2019&quot;), radioButtons(inputId = &quot;nb_pieces&quot;, label = &quot;Choix du nombre de pièces pour le graphique&quot;, choices = levels(dvf_Paris_1$nbpieces_cat), selected = &quot;Deux pièces&quot;) ), # Tableau et graphe montré à l&#39;utilisateur mainPanel( gt_output(&quot;tab&quot;), br(), br(), plotOutput(&quot;barplot&quot;) ) ) ) server &lt;- function(input, output) { output$tab &lt;- render_gt({ dvf_Paris_1 %&gt;% filter(n==1 &amp; annee == input$annee) %&gt;% summarise(&quot;Nombre de ventes d&#39;appartements&quot; = sum(nombre_lots), &quot;Prix moyen au m2 des appartements, en €&quot; = round(mean(px_m2)), &quot;Prix médian au m2 des appartements, en €&quot; = round(median(px_m2)), &quot;Nombre moyen de pièces&quot; = round(mean(nombre_pieces_principales))) %&gt;% gt() %&gt;% fmt_number(columns= 1:3, sep_mark = &quot; &quot;, decimals = 0) %&gt;% tab_header(title=paste(&#39;Principaux indicateurs en&#39;, input$annee)) }) output$barplot &lt;- renderPlot({ dvf_Paris_1 %&gt;% filter(annee == input$annee &amp; nbpieces_cat==input$nb_pieces &amp; n==1) %&gt;% group_by(nom_arrdt) %&gt;% summarise(med_prixm2 = round(median(px_m2))) %&gt;% arrange(desc(med_prixm2)) %&gt;% slice(1:5) ggplot() + aes(x = med_prixm2, y = fct_reorder(nom_arrdt, med_prixm2)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;darkgoldenrod1&quot;) + geom_text(aes(label=med_prixm2), position = position_stack(vjust=0.5), size=3.8) + labs(title = paste(&quot;Top 5 des arrondissements ayant les prix médians au m2 des ventes \\nd&#39;appartements&quot;, ifelse(input$nb_pieces==&quot;Une pièce&quot;, &quot;d&#39;une pièce&quot;, ifelse(input$nb_pieces==&quot;Deux pièces&quot;, &quot;de deux pièces&quot;, ifelse(input$nb_pieces==&quot;Trois pièces ou plus&quot;, &quot;de trois pièces ou plus&quot;))), &quot;les plus élevés en&quot;, input$annee), x=&quot; &quot;, y=&quot; &quot;, caption = &quot;Source : Base &#39;demande de valeurs foncières&#39;, 2019-2022.&quot;) + theme_classic() + theme(plot.title = element_text(size=17), plot.caption = element_text(hjust = 0, size=12), axis.text.y = element_text(size=12.5), axis.text.x = element_text(size=12.5)) }) } shinyApp(ui = ui, server = server) 11.2 Introduction d’une réactivité appliquée à la table de données On peut rendre maintenant la base de données réactive avec la fonction reactive({}). On l’avait vu, la fonction reactive() permet de créer un objet réactif qui est à la fois une entrée réactive et une sortie réactive, l’objet va donc se mettre à jour automatiquement si les entrées qu’il utilise changent, et il va automatiquement déclencher la mise à jour des sorties où il est utilisé. La fonction permet techniquement de décomposer du code réactif et est utile lorsque certaines parties du code sont utilisées par plusieurs outputs car elle va permettre alors d’éviter des redondances. Cela peut être le cas lorsqu’on doit filtrer et/ou sélectionner des mêmes variables en input pour plusieurs outputs. Ici, on va décomposer la partie ‘data’ du code précédent de la partie construction du graphique ; le rendu sera strictement le même ; mais cela peut être plus efficace en cas de long code et d’application complexe car en gros on va exécuter qu’une seule fois l’opération ‘data’ réalisée ici. Attention, la base réactive créée est une fonction, il faut donc l’appeler avec des parenthèses ! # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Caractéristiques des ventes d&#39;appartements dans Paris sur la période 2019-2022&quot;), br(), # Définition du Widget sidebarLayout( sidebarPanel( selectInput(inputId = &quot;annee&quot;, label = &quot;Choix de l&#39;année de vente pour le tableau et le graphique&quot;, choices = list(&quot;2019&quot;, &quot;2020&quot;, &quot;2021&quot;,&quot;2022&quot;), selected = &quot;2019&quot;), radioButtons(inputId = &quot;nb_pieces&quot;, label = &quot;Choix du nombre de pièces pour le graphique&quot;, choices = levels(dvf_Paris_1$nbpieces_cat), selected = &quot;Deux pièces&quot;) ), # Tableau et graphe montré à l&#39;utilisateur mainPanel( gt_output(&quot;tab&quot;), br(), br(), plotOutput(&quot;barplot&quot;) ) ) ) server &lt;- function(input, output) { output$tab &lt;- render_gt({ dvf_Paris_1 %&gt;% filter(nombre_lots==&quot;1&quot; &amp; annee == input$annee) %&gt;% summarise(&quot;Nombre de ventes d&#39;appartements&quot; = sum(nombre_lots), &quot;Prix moyen au m2 des appartements, en €&quot; = round(mean(px_m2)), &quot;Prix médian au m2 des appartements, en €&quot; = round(median(px_m2)), &quot;Nombre moyen de pièces&quot; = round(mean(nombre_pieces_principales))) %&gt;% gt() %&gt;% fmt_number(columns= 1:3, sep_mark = &quot; &quot;, decimals = 0) %&gt;% tab_header(title=md(&#39;**Principaux indicateurs sur la période 2019-2022**&#39;)) }) dvf_Paris_react &lt;- reactive({ dvf_Paris_1 %&gt;% filter(annee == input$annee &amp; nbpieces_cat==input$nb_pieces &amp; annee == input$annee) %&gt;% group_by(nom_arrdt) %&gt;% summarise(med_prixm2 = round(median(px_m2))) %&gt;% arrange(desc(med_prixm2)) %&gt;% slice(1:5) }) output$barplot &lt;- renderPlot({ dvf_Paris_react() %&gt;% ggplot() + aes(x = med_prixm2, y = fct_reorder(nom_arrdt, med_prixm2)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;darkgoldenrod1&quot;) + geom_text(aes(label=med_prixm2), position = position_stack(vjust=0.5), size=3.8) + labs(title = paste(&quot;Top 5 des arrondissements ayant les prix médians au m2 des ventes \\nd&#39;appartements&quot;, ifelse(input$nb_pieces==&quot;Une pièce&quot;, &quot;d&#39;une pièce&quot;, ifelse(input$nb_pieces==&quot;Deux pièces&quot;, &quot;de deux pièces&quot;, ifelse(input$nb_pieces==&quot;Trois pièces ou plus&quot;, &quot;de trois pièces ou plus&quot;))), &quot;les plus élevés en&quot;, input$annee), x=&quot; &quot;, y=&quot; &quot;, caption = &quot;Source : Base &#39;demande de valeurs foncières&#39;, 2019-2022.&quot;) + theme_classic() + theme(plot.title = element_text(size=17), plot.caption = element_text(hjust = 0, size=12), axis.text.y = element_text(size=12.5), axis.text.x = element_text(size=12.5)) }) } shinyApp(ui = ui, server = server) 11.3 Introduction d’une réactivité sur les inputs (contexte réactif) On va maintenant introduire un contexte réactif. Pour cela, on va repartir de la base du RP, puisqu’on peut y distinguer les départements et les communes, en s’intéressant à la répartition de la population de 15-64 ans selon le type d’activité, et donc par département et commune. On va de façon comparable à ce qu’on a fait précédemment, créer en haut un tableau qui donnera cette répartition pour le département ; puis en-dessous un graphique qui montrera cette répartition pour une des communes de ce département. On aura donc deux widgets, un pour le choix du département et un pour le choix de la commune. On veut que lorsqu’on choisit Paris en département par exemple, le widget de la commune ne nous montre que les arrondissements de Paris (et non toutes les communes des 4 départements de notre champ), etc. On peut pour cela utiliser la fonction observe() : on l’utilise donc quand un input change. Il va falloir ici utiliser à l’intérieur de la fonction observe() une condition if ... else ... : on part du principe qu’on affiche d’abord automatiquement le département “75”, lorsque l’utilisateur appuie sur le bouton du choix de département du widget radioButtons, le widget selectInput doit être actualisé en permettant les seuls choix de communes de Paris donc les arrondissements ; de même pour les autres départements. Il faut donc utiliser la fonction observe(), une condition if ... else ... et une actualisation des widgets avec la fonction updateSelectInput(). L’image suivante vous donne un aperçu de ce qu’on devrait avoir pour Paris : # Définition UI et Server de l&#39;application Shiny ui &lt;- fluidPage( # Titre de l&#39;application titlePanel(&quot;Type d&#39;activité de la population des 15-64 ans selon le département et la commune dans Paris et sa petite couronne&quot;), # Définition du Widget sidebarLayout( sidebarPanel( radioButtons(inputId = &quot;dept&quot;, label = &quot;Choix du département pour le tableau et le graphique&quot;, choices = unique(RP_final$DEPT), selected = &quot;75&quot;), selectInput(inputId = &quot;commune&quot;, label = &quot;Choix de la commune pour le graphique&quot;, choices = unique(RP_final$COM), selected = &quot;75112&quot;) ), # Tableau et graphe montré à l&#39;utilisateur mainPanel( gt_output(&quot;tab&quot;), br(), plotOutput(&quot;barplot&quot;) ) ) ) server &lt;- function(input, output) { RP_final_react &lt;- reactive({ RP_final %&gt;% filter(AGEREV&gt;=15 &amp; AGEREV&lt;=64 &amp; DEPT==input$dept) %&gt;% mutate(TACT_moda1=as.factor(case_when(TACT == &quot;11&quot; ~ &quot;Actifs ayant un emploi&quot;, TACT == &quot;12&quot; ~ &quot;Chômeurs&quot;, TACT == &quot;22&quot; ~ &quot;Élèves, étudiants et stagiaires non rémunérés&quot;, TACT == &quot;21&quot; ~ &quot;Retraités ou préretraités&quot;, TRUE ~ &quot;Autres inactifs&quot;))) }) observe({ input$dept if(input$dept == &quot;75&quot;){ updateSelectInput(inputId = &quot;commune&quot;, choices = unique(RP_final[RP_final$DEPT==&quot;75&quot;, ]$COM), selected = &quot;75112&quot;) } else {updateSelectInput(inputId = &quot;commune&quot;, choices = unique(RP_final[RP_final$DEPT==input$dept, ]$COM), selected = input$variable) } }) output$tab &lt;- render_gt({ RP_final_react() %&gt;% count(TACT_moda1, wt=IPONDI) %&gt;% mutate(Pourcentage=round(prop.table(n)*100,1)) %&gt;% arrange(desc(Pourcentage)) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% rename(Effectif=n, &quot;Type d&#39;activité&quot;=TACT_moda1) %&gt;% gt() %&gt;% fmt_number(columns = 2, sep_mark = &quot; &quot;, decimals = 0) %&gt;% tab_header(title = paste(&quot;Département affiché :&quot;, input$dept)) }) output$barplot &lt;- renderPlot({ RP_final_react() %&gt;% filter(COM==input$commune) %&gt;% count(TACT_moda1, wt=IPONDI) %&gt;% mutate(Pourcentage=round(prop.table(n)*100,0)) %&gt;% select(-n) %&gt;% ggplot() + aes(x=fct_reorder(TACT_moda1, desc(Pourcentage)), y=Pourcentage) + geom_bar(stat = &quot;identity&quot;, fill=&quot;darkgoldenrod1&quot;) + geom_text(aes(label=Pourcentage), position = position_stack(vjust=0.5), size=4.7) + labs(title=paste(&quot;Répartition de la population en % par type d&#39;activité du&quot;, input$commune), x = &quot;&quot;, y = &quot; &quot;) + theme_classic() + theme(plot.title=element_text(size=18), axis.text.x = element_text(size=12, angle=45, hjust=1)) }) } shinyApp(ui = ui, server = server) "],["11-Clustering-theorique.html", "Section 12 Clustering : aspects théoriques 12.1 La classification ascendante hiérarchique (CAH) 12.2 La méthode des centres mobiles et sa variante, les K-means", " Section 12 Clustering : aspects théoriques Les méthodes de clustering (ou typologie, ou segmentation, ou encore classification en français2) appartiennent à la famille des algorithmes d’apprentissage non supervisé, car nous n’avons pas de variable de sortie ou variable-cible. Ce sont justement les algorithmes qui vont chercher à organiser les observations en groupes ou classes dit “clusters” en fonction de variables quantitatives choisies en entrée/input dans le modèle. L’algorithme va ensuite chercher à ce que ces “clusters” soient à la fois le plus similaire possible à l’intérieur/en leur sein (forte “similarité intraclasse”, on cherche alors à minimiser l’inertie intraclasse) et le plus distinctif/différent des autres groupes/classes (faible “similarité interclasse”, on parlera de maximisation de l’inertie interclasse). Ces observations peuvent être des individus, des entreprises, ou comme ici pour nous, un niveau territorial (la commune). Représentation graphique Inertie totale, interclasse et intraclasse Source : document de cours accessible ici http://iml.univ-mrs.fr/~reboul/ADD4-MAB.pdf Il y a deux principales méthodes de clustering : hiérarchique et non hiérarchique, la principale différence étant que pour la premiere on ne connaît pas par avance le nombre de groupes dans lesquels seront réparties nos observations ; alors que pour la seconde, on fixe au préalable le nombre de groupes. On va étudier ici deux exemples : pour le clustering hiérarchique, on va utiliser la méthode la plus courante - la classification ascendante hiérarchique (CAH) - qui utilise un algorithme ascendant, c’est-à-dire agglomératif (les classes sont construites par agglomérations successives des objets deux à deux ; cette méthode s’oppose aux algorithmes descendants ou divisifs) ; et pour le clustering non hiérarchique, la méthode également la plus utilisée - les centres-mobiles ou la méthodes des K-means (très légèrement différente). Pour d’autres exemples, vous pouvez vous référer respectivement aux pages 244-251, et 252-255, du manuel de référence du cours (Husson, 2018). 12.1 La classification ascendante hiérarchique (CAH) Voici une représentation générale d’un clustering hiérarhique : Représentation graphique clustering hiérarchique Source : document de cours accessible ici https://perso.univ-rennes1.fr/valerie.monbet/ExposesM2/2013/Classification2.pdf Il y a en gros 3 grandes étapes : une première étape, facultative, car cela dépend de la nature des données : on centre et réduit les variables, on dit également qu’on “standardise” les variables. Cela est indispensable quand les variables ont des unités différentes (le poids et la taille d’un individu) ; si elles ont des unités similaires (c’est notre cas ici), il faut choisir de le faire ou non. Souvent, on va choisir de “standardiser” car on peut avoir des variables avec des écarts-types importants ce qui peut créer un biais (en faveur de ces variables, c’est-à-dire en leur donnant un poids plus important dans l’analyse) lors de la construction de la matrice de distances. une seconde étape consiste à créer une matrice des distances (ou des dissimilarités) car la construction de l’arbre (cf. ci-dessous) repose sur les distances entre observations/individus : l’idée est de chercher les individus les plus proches ou les plus ressemblants ; on commence donc par calculer la matrice des distances des individus deux à deux, puis on rassemble les deux plus proches dans un nouvel élément ce qui crée une matrice des distances sur les n-1 individus, ensuite on réitère le processus - on crée une matrice des distances rassemblant les deux individus les plus proches dans un nouveau groupe, etc. - jusqu’à ce qu’on n’ait plus qu’un seul élément. Dans cette étape, on choisit le type de distance utilisé, c’est-à-dire le critère de ressemblance entre les individus. Sans rentrer ici plus dans les détails, la méthode de distance la plus utilisée et (ou car) la plus intuitive est la distance euclidienne. Mais par exemple, si nos variables ne sont pas mesurées en effectifs mais en proportion, il faudra plutôt utiliser la distance du khi-deux. Autre exemple, lorsque les variables seront qualitatives de type binaire (0/1), alors ce sera plutôt l’indice de similarité de Jaccard qui sera utilisé. enfin, la troisième étape est la méthode d’agrégation : dans la construction de la matrice de distance, après la 1ère étape (n-1 individus), ce seront progressivement des groupes d’individus dont on comparera la distance, il faut donc savoir comment calculer cette distance entre groupes (et non plus seulement entre individus) : est-ce qu’on prend le point représentant l’individu moyen du groupe ? Ou bien celui qui est à l’extrêmité du groupe ? Etc. Là aussi, il faut donc choisir cette méthode d’agrégation parmi un ensemble de méthodes (lien simple ou minimum, lien maximum, lien moyen, lien entre les centroïdes/centres de gravité ou barycentre, critère de Ward) : la plus utilisée est le critère de Ward, notamment lorsqu’on utilise une distance euclidienne dans l’étape précédente. Ce critère se base sur la décomposition de l’inertie totale (somme du carré des distances de chaque point au centre) en une inertie intraclasse et une inertie interclasse ; il consiste ensuite à minimiser la perte d’inertie intraclasse à chaque agrégation de classes, pour que les classes restent le plus homogène possible. Un schéma de 3 de ces distances permet de mieux visualiser ce dont il s’agit : Representation graphique de 3 critères d’agrégation Source : document de cours accessible ici https://r.developpez.com/tutoriels/programmation-graphe/livre-R-et-espace/?page=chapitre-7-methodes-de-classification On doit ainsi aboutir à un arbre appelé dendogramme, dont le haut ou la “racine” est constituée d’une unique classe/cluster qui rassemble tous les individus, alors que le bas (l’ensemble des “feuilles”) constituent des clusters à un individu donc avec une homogénéité, par définition parfaite. Selon la méthode d’agrégation utilisée, les dendogrammes pourront avoir des formes bien différentes (c’est ce que nous verrons dans l’exemple d’application), il ne faut donc pas hésiter à tester différentes méthodes pour rendre plus robuste le résultat final c’est-à-dire la classification, en gros elle sera robuste si le “haut” de l’arbre ne change pas trop (= on a toujours les même 3 ou 4 ou 5 grosses classes). Un exemple d’application d’un clustering hiérarchique avec 7 individus, basée sur une distance euclidienne et la méthode de Ward, est disponible ici. 12.2 La méthode des centres mobiles et sa variante, les K-means L’objectif est cette fois de construire une partition d’une population en k “clusters”, ce nombre k étant fixé avant ou a priori. C’est la principale différence en réalité par rapport à la méthode précédente, et le résultat en sera une partition unique des données (contrairement à la CAH qui donne une sorte de hiérarchie de partitions avec le dendogramme, à partir de laquelle il faut choisir le nombre de classes). L’algorithme des centres mobiles repose sur un processus itératif de plusieurs étapes : on détermine aléatoirement (c’est-à-dire au hasard) k individus/observations comme centres provisoires de classes, et on affecte chaque individu à la classe dont le centre est le plus proche, ce qui crée une première partition ; ensuite, on procède à un nouveau calcul des centres de gravité des classes de cette première partition, on redistribue les individus dans la classe dont le centre est le plus proche, ce qui permet d’aboutir à une seconde partition alternative ; on répète ce processus jusqu’à convergence (selon un critère que l’on peut définir), c’est-à-dire jusqu’à ce qu’aucun individu ne change de classe, ou lorsque l’inertie intra-classe ne diminue plus, ou encore lorsque les centres de classes sont stables, ou lorsque tout simplement on a atteint le nombre d’itérations que l’on avait fixé. Il y a donc, ici aussi (mais plus implicitement), une minimisation de l’inertie intra-classe. Une variante est qu’une actualisation ou un recalcul des centres de classe peut être fait dès qu’un individu change de classe ; néanmoins dans cette variance, l’ordre des individus joue dans le résultat final. Voici une représentation graphique illustrant la méthode : Légèrement différente, la méthode des k-means va recalculer le centre de classe à chaque fois qu’un nouvel individu y est introduit, alors que précédemment on attendait que tous les individus soient affectés dans des groupes pour recalculer le centre de classe. Le nouveau calcul du cente de classe est donc ici effectué dès qu’un individu change de classe. L’une des limites de cette méthode (et sa variante) est que la partition finale, résultat de ce processus itératif, dépend souvent des centres initiaux de classes qui ont été choisis, c’est pourquoi en pratique il est préférable d’exécuter plusieurs fois la procédure, et comme précédemment de choisir la partition la plus stable/robuste. Cette méthode est souvent utilisée lorsque l’on a de grosses bases de données sur lesquelles faire tourner une CAH est très coûteuse en temps ; toutefois, le fait de devoir répéter plusieurs fois la procédure jusqu’à stabilité des classes peut atténuer cette avantage de rapidité de calcul pour les grandes bases. On peut l’utiliser aussi en complément d’une CAH là aussi sur de grosses bases de données, plus précisément comme étape préalable à une CAH, l’idée étant de choisir un très grand nombre de centres de classes pour réaliser la CAH sur ces centres considérés comme les individus, et ensuite aboutir à un nombre plus petit de classes finales, c’est ce qu’on appelle la méthode de classification ou clustering mixte. Attention néanmoins à l’usage du terme “classification” car en anglais et dans la plupart des ouvrages de Data Science et de Machine Learning, ce terme renvoie aux techniques d’analyse prédictive dont la variable cible (d’intérêt) est qualitative (en opposition aux régressions pour lesquelles la variable cible est quantitative). L’usage du terme “clustering” est ainsi privilégié.↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
